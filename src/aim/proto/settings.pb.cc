// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: settings.proto
// Protobuf C++ Version: 5.29.3

#include "settings.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace aim {

inline constexpr SoundSettings::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        hit_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        kill_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        metronome_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        shoot_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR SoundSettings::SoundSettings(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SoundSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SoundSettingsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SoundSettingsDefaultTypeInternal() {}
  union {
    SoundSettings _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SoundSettingsDefaultTypeInternal _SoundSettings_default_instance_;

inline constexpr PlusCrosshair::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        rounding_{0},
        horizontal_size_{0},
        vertical_size_{0},
        thickness_{0},
        outline_thickness_{0},
        vertical_gap_size_{0},
        horizontal_gap_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR PlusCrosshair::PlusCrosshair(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct PlusCrosshairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlusCrosshairDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlusCrosshairDefaultTypeInternal() {}
  union {
    PlusCrosshair _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlusCrosshairDefaultTypeInternal _PlusCrosshair_default_instance_;

inline constexpr KeyMapping::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        mapping1_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        mapping2_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        mapping3_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        mapping4_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR KeyMapping::KeyMapping(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct KeyMappingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeyMappingDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeyMappingDefaultTypeInternal() {}
  union {
    KeyMapping _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeyMappingDefaultTypeInternal _KeyMapping_default_instance_;

inline constexpr ImageCrosshair::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        file_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR ImageCrosshair::ImageCrosshair(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ImageCrosshairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ImageCrosshairDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ImageCrosshairDefaultTypeInternal() {}
  union {
    ImageCrosshair _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageCrosshairDefaultTypeInternal _ImageCrosshair_default_instance_;

inline constexpr HealthBarSettings::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        show_{false},
        only_damaged_{false},
        height_{0},
        width_{0},
        height_above_target_{0} {}

template <typename>
PROTOBUF_CONSTEXPR HealthBarSettings::HealthBarSettings(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct HealthBarSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HealthBarSettingsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~HealthBarSettingsDefaultTypeInternal() {}
  union {
    HealthBarSettings _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HealthBarSettingsDefaultTypeInternal _HealthBarSettings_default_instance_;

inline constexpr DotCrosshair::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        outline_thickness_{0} {}

template <typename>
PROTOBUF_CONSTEXPR DotCrosshair::DotCrosshair(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DotCrosshairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DotCrosshairDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DotCrosshairDefaultTypeInternal() {}
  union {
    DotCrosshair _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DotCrosshairDefaultTypeInternal _DotCrosshair_default_instance_;

inline constexpr CircleCrosshair::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        thickness_{0},
        use_outline_color_{false} {}

template <typename>
PROTOBUF_CONSTEXPR CircleCrosshair::CircleCrosshair(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CircleCrosshairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CircleCrosshairDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CircleCrosshairDefaultTypeInternal() {}
  union {
    CircleCrosshair _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CircleCrosshairDefaultTypeInternal _CircleCrosshair_default_instance_;

inline constexpr ScenarioSettings::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        theme_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        crosshair_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        health_bar_{nullptr},
        cm_per_360_{0},
        metronome_bpm_{0},
        crosshair_size_{0},
        cm_per_360_jitter_{0},
        auto_hold_tracking_{false} {}

template <typename>
PROTOBUF_CONSTEXPR ScenarioSettings::ScenarioSettings(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct ScenarioSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ScenarioSettingsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ScenarioSettingsDefaultTypeInternal() {}
  union {
    ScenarioSettings _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ScenarioSettingsDefaultTypeInternal _ScenarioSettings_default_instance_;

inline constexpr Keybinds::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        fire_{nullptr},
        restart_scenario_{nullptr},
        next_scenario_{nullptr},
        quick_settings_{nullptr},
        adjust_crosshair_size_{nullptr},
        quick_metronome_{nullptr},
        edit_scenario_{nullptr} {}

template <typename>
PROTOBUF_CONSTEXPR Keybinds::Keybinds(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct KeybindsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KeybindsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KeybindsDefaultTypeInternal() {}
  union {
    Keybinds _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KeybindsDefaultTypeInternal _Keybinds_default_instance_;

inline constexpr CrosshairLayer::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        override_color_{nullptr},
        override_outline_color_{nullptr},
        scale_{0},
        alpha_{0},
        type_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR CrosshairLayer::CrosshairLayer(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CrosshairLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CrosshairLayerDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CrosshairLayerDefaultTypeInternal() {}
  union {
    CrosshairLayer _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrosshairLayerDefaultTypeInternal _CrosshairLayer_default_instance_;

inline constexpr Crosshair::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        layers_{},
        name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()) {}

template <typename>
PROTOBUF_CONSTEXPR Crosshair::Crosshair(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct CrosshairDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CrosshairDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CrosshairDefaultTypeInternal() {}
  union {
    Crosshair _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CrosshairDefaultTypeInternal _Crosshair_default_instance_;

inline constexpr Settings::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        saved_crosshairs_{},
        theme_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        current_crosshair_name_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        keybinds_{nullptr},
        health_bar_{nullptr},
        sound_{nullptr},
        dpi_{0},
        cm_per_360_{0},
        metronome_bpm_{0},
        crosshair_size_{0},
        disable_click_to_start_{false},
        auto_hold_tracking_{false},
        disable_per_scenario_settings_{false},
        cm_per_360_jitter_{0},
        max_render_fps_{0} {}

template <typename>
PROTOBUF_CONSTEXPR Settings::Settings(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SettingsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SettingsDefaultTypeInternal() {}
  union {
    Settings _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SettingsDefaultTypeInternal _Settings_default_instance_;

inline constexpr SavedCrosshairs::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : crosshairs_{},
        _cached_size_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SavedCrosshairs::SavedCrosshairs(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SavedCrosshairsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SavedCrosshairsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SavedCrosshairsDefaultTypeInternal() {}
  union {
    SavedCrosshairs _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SavedCrosshairsDefaultTypeInternal _SavedCrosshairs_default_instance_;
}  // namespace aim
static constexpr const ::_pb::EnumDescriptor**
    file_level_enum_descriptors_settings_2eproto = nullptr;
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_settings_2eproto = nullptr;
const ::uint32_t
    TableStruct_settings_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        PROTOBUF_FIELD_OFFSET(::aim::DotCrosshair, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::DotCrosshair, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::DotCrosshair, _impl_.outline_thickness_),
        0,
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _impl_.rounding_),
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _impl_.horizontal_size_),
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _impl_.vertical_size_),
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _impl_.thickness_),
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _impl_.outline_thickness_),
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _impl_.vertical_gap_size_),
        PROTOBUF_FIELD_OFFSET(::aim::PlusCrosshair, _impl_.horizontal_gap_size_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        PROTOBUF_FIELD_OFFSET(::aim::CircleCrosshair, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::CircleCrosshair, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::CircleCrosshair, _impl_.thickness_),
        PROTOBUF_FIELD_OFFSET(::aim::CircleCrosshair, _impl_.use_outline_color_),
        0,
        1,
        PROTOBUF_FIELD_OFFSET(::aim::ImageCrosshair, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::ImageCrosshair, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::ImageCrosshair, _impl_.file_name_),
        0,
        PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _internal_metadata_),
        ~0u,  // no _extensions_
        PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _impl_._oneof_case_[0]),
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _impl_.override_color_),
        PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _impl_.override_outline_color_),
        PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _impl_.scale_),
        PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _impl_.alpha_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _impl_.type_),
        0,
        1,
        2,
        3,
        ~0u,
        ~0u,
        ~0u,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::aim::Crosshair, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::Crosshair, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::Crosshair, _impl_.name_),
        PROTOBUF_FIELD_OFFSET(::aim::Crosshair, _impl_.layers_),
        0,
        ~0u,
        PROTOBUF_FIELD_OFFSET(::aim::HealthBarSettings, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::HealthBarSettings, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::HealthBarSettings, _impl_.show_),
        PROTOBUF_FIELD_OFFSET(::aim::HealthBarSettings, _impl_.only_damaged_),
        PROTOBUF_FIELD_OFFSET(::aim::HealthBarSettings, _impl_.height_),
        PROTOBUF_FIELD_OFFSET(::aim::HealthBarSettings, _impl_.width_),
        PROTOBUF_FIELD_OFFSET(::aim::HealthBarSettings, _impl_.height_above_target_),
        0,
        1,
        2,
        3,
        4,
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::aim::SavedCrosshairs, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::SavedCrosshairs, _impl_.crosshairs_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.dpi_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.cm_per_360_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.cm_per_360_jitter_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.theme_name_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.metronome_bpm_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.crosshair_size_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.current_crosshair_name_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.saved_crosshairs_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.disable_click_to_start_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.keybinds_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.auto_hold_tracking_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.health_bar_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.disable_per_scenario_settings_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.max_render_fps_),
        PROTOBUF_FIELD_OFFSET(::aim::Settings, _impl_.sound_),
        5,
        6,
        12,
        0,
        7,
        8,
        1,
        ~0u,
        9,
        2,
        10,
        3,
        11,
        13,
        4,
        PROTOBUF_FIELD_OFFSET(::aim::SoundSettings, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::SoundSettings, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::SoundSettings, _impl_.hit_),
        PROTOBUF_FIELD_OFFSET(::aim::SoundSettings, _impl_.kill_),
        PROTOBUF_FIELD_OFFSET(::aim::SoundSettings, _impl_.metronome_),
        PROTOBUF_FIELD_OFFSET(::aim::SoundSettings, _impl_.shoot_),
        0,
        1,
        2,
        3,
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_.cm_per_360_),
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_.cm_per_360_jitter_),
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_.theme_name_),
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_.metronome_bpm_),
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_.crosshair_size_),
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_.crosshair_name_),
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_.auto_hold_tracking_),
        PROTOBUF_FIELD_OFFSET(::aim::ScenarioSettings, _impl_.health_bar_),
        3,
        6,
        0,
        4,
        5,
        1,
        7,
        2,
        PROTOBUF_FIELD_OFFSET(::aim::KeyMapping, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::KeyMapping, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::KeyMapping, _impl_.mapping1_),
        PROTOBUF_FIELD_OFFSET(::aim::KeyMapping, _impl_.mapping2_),
        PROTOBUF_FIELD_OFFSET(::aim::KeyMapping, _impl_.mapping3_),
        PROTOBUF_FIELD_OFFSET(::aim::KeyMapping, _impl_.mapping4_),
        0,
        1,
        2,
        3,
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        ~0u,  // no _inlined_string_donated_
        ~0u,  // no _split_
        ~0u,  // no sizeof(Split)
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _impl_.fire_),
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _impl_.restart_scenario_),
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _impl_.next_scenario_),
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _impl_.quick_settings_),
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _impl_.adjust_crosshair_size_),
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _impl_.quick_metronome_),
        PROTOBUF_FIELD_OFFSET(::aim::Keybinds, _impl_.edit_scenario_),
        0,
        1,
        2,
        3,
        4,
        5,
        6,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, 9, -1, sizeof(::aim::DotCrosshair)},
        {10, 25, -1, sizeof(::aim::PlusCrosshair)},
        {32, 42, -1, sizeof(::aim::CircleCrosshair)},
        {44, 53, -1, sizeof(::aim::ImageCrosshair)},
        {54, 71, -1, sizeof(::aim::CrosshairLayer)},
        {79, 89, -1, sizeof(::aim::Crosshair)},
        {91, 104, -1, sizeof(::aim::HealthBarSettings)},
        {109, -1, -1, sizeof(::aim::SavedCrosshairs)},
        {118, 141, -1, sizeof(::aim::Settings)},
        {156, 168, -1, sizeof(::aim::SoundSettings)},
        {172, 188, -1, sizeof(::aim::ScenarioSettings)},
        {196, 208, -1, sizeof(::aim::KeyMapping)},
        {212, 227, -1, sizeof(::aim::Keybinds)},
};
static const ::_pb::Message* const file_default_instances[] = {
    &::aim::_DotCrosshair_default_instance_._instance,
    &::aim::_PlusCrosshair_default_instance_._instance,
    &::aim::_CircleCrosshair_default_instance_._instance,
    &::aim::_ImageCrosshair_default_instance_._instance,
    &::aim::_CrosshairLayer_default_instance_._instance,
    &::aim::_Crosshair_default_instance_._instance,
    &::aim::_HealthBarSettings_default_instance_._instance,
    &::aim::_SavedCrosshairs_default_instance_._instance,
    &::aim::_Settings_default_instance_._instance,
    &::aim::_SoundSettings_default_instance_._instance,
    &::aim::_ScenarioSettings_default_instance_._instance,
    &::aim::_KeyMapping_default_instance_._instance,
    &::aim::_Keybinds_default_instance_._instance,
};
const char descriptor_table_protodef_settings_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\016settings.proto\022\003aim\032\014common.proto\")\n\014D"
    "otCrosshair\022\031\n\021outline_thickness\030\004 \001(\002\"\267"
    "\001\n\rPlusCrosshair\022\020\n\010rounding\030\001 \001(\002\022\027\n\017ho"
    "rizontal_size\030\002 \001(\002\022\025\n\rvertical_size\030\003 \001"
    "(\002\022\021\n\tthickness\030\004 \001(\002\022\031\n\021outline_thickne"
    "ss\030\005 \001(\002\022\031\n\021vertical_gap_size\030\006 \001(\002\022\033\n\023h"
    "orizontal_gap_size\030\007 \001(\002\"\?\n\017CircleCrossh"
    "air\022\021\n\tthickness\030\001 \001(\002\022\031\n\021use_outline_co"
    "lor\030\002 \001(\010\"#\n\016ImageCrosshair\022\021\n\tfile_name"
    "\030\001 \001(\t\"\246\002\n\016CrosshairLayer\022(\n\016override_co"
    "lor\030\001 \001(\0132\020.aim.StoredColor\0220\n\026override_"
    "outline_color\030\002 \001(\0132\020.aim.StoredColor\022\r\n"
    "\005scale\030\003 \001(\002\022\r\n\005alpha\030\004 \001(\002\022 \n\003dot\030\n \001(\013"
    "2\021.aim.DotCrosshairH\000\022\"\n\004plus\030\013 \001(\0132\022.ai"
    "m.PlusCrosshairH\000\022$\n\005image\030\014 \001(\0132\023.aim.I"
    "mageCrosshairH\000\022&\n\006circle\030\r \001(\0132\024.aim.Ci"
    "rcleCrosshairH\000B\006\n\004type\">\n\tCrosshair\022\014\n\004"
    "name\030\001 \001(\t\022#\n\006layers\030\002 \003(\0132\023.aim.Crossha"
    "irLayer\"s\n\021HealthBarSettings\022\014\n\004show\030\001 \001"
    "(\010\022\024\n\014only_damaged\030\002 \001(\010\022\016\n\006height\030\003 \001(\002"
    "\022\r\n\005width\030\004 \001(\002\022\033\n\023height_above_target\030\005"
    " \001(\002\"5\n\017SavedCrosshairs\022\"\n\ncrosshairs\030\001 "
    "\003(\0132\016.aim.Crosshair\"\276\003\n\010Settings\022\013\n\003dpi\030"
    "\001 \001(\002\022\022\n\ncm_per_360\030\002 \001(\002\022\031\n\021cm_per_360_"
    "jitter\030\013 \001(\002\022\022\n\ntheme_name\030\003 \001(\t\022\025\n\rmetr"
    "onome_bpm\030\004 \001(\002\022\026\n\016crosshair_size\030\005 \001(\002\022"
    "\036\n\026current_crosshair_name\030\006 \001(\t\022(\n\020saved"
    "_crosshairs\030\007 \003(\0132\016.aim.Crosshair\022\036\n\026dis"
    "able_click_to_start\030\010 \001(\010\022\037\n\010keybinds\030\t "
    "\001(\0132\r.aim.Keybinds\022\032\n\022auto_hold_tracking"
    "\030\n \001(\010\022*\n\nhealth_bar\030\014 \001(\0132\026.aim.HealthB"
    "arSettings\022%\n\035disable_per_scenario_setti"
    "ngs\030\r \001(\010\022\026\n\016max_render_fps\030\016 \001(\002\022!\n\005sou"
    "nd\030\017 \001(\0132\022.aim.SoundSettings\"L\n\rSoundSet"
    "tings\022\013\n\003hit\030\001 \001(\t\022\014\n\004kill\030\002 \001(\t\022\021\n\tmetr"
    "onome\030\003 \001(\t\022\r\n\005shoot\030\004 \001(\t\"\344\001\n\020ScenarioS"
    "ettings\022\022\n\ncm_per_360\030\001 \001(\002\022\031\n\021cm_per_36"
    "0_jitter\030\006 \001(\002\022\022\n\ntheme_name\030\002 \001(\t\022\025\n\rme"
    "tronome_bpm\030\003 \001(\002\022\026\n\016crosshair_size\030\004 \001("
    "\002\022\026\n\016crosshair_name\030\005 \001(\t\022\032\n\022auto_hold_t"
    "racking\030\007 \001(\010\022*\n\nhealth_bar\030\010 \001(\0132\026.aim."
    "HealthBarSettings\"T\n\nKeyMapping\022\020\n\010mappi"
    "ng1\030\001 \001(\t\022\020\n\010mapping2\030\002 \001(\t\022\020\n\010mapping3\030"
    "\003 \001(\t\022\020\n\010mapping4\030\004 \001(\t\"\247\002\n\010Keybinds\022\035\n\004"
    "fire\030\001 \001(\0132\017.aim.KeyMapping\022)\n\020restart_s"
    "cenario\030\002 \001(\0132\017.aim.KeyMapping\022&\n\rnext_s"
    "cenario\030\003 \001(\0132\017.aim.KeyMapping\022\'\n\016quick_"
    "settings\030\004 \001(\0132\017.aim.KeyMapping\022.\n\025adjus"
    "t_crosshair_size\030\005 \001(\0132\017.aim.KeyMapping\022"
    "(\n\017quick_metronome\030\006 \001(\0132\017.aim.KeyMappin"
    "g\022&\n\redit_scenario\030\007 \001(\0132\017.aim.KeyMappin"
    "gb\010editionsp\350\007"
};
static const ::_pbi::DescriptorTable* const descriptor_table_settings_2eproto_deps[1] =
    {
        &::descriptor_table_common_2eproto,
};
static ::absl::once_flag descriptor_table_settings_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_settings_2eproto = {
    false,
    false,
    2054,
    descriptor_table_protodef_settings_2eproto,
    "settings.proto",
    &descriptor_table_settings_2eproto_once,
    descriptor_table_settings_2eproto_deps,
    1,
    13,
    schemas,
    file_default_instances,
    TableStruct_settings_2eproto::offsets,
    file_level_enum_descriptors_settings_2eproto,
    file_level_service_descriptors_settings_2eproto,
};
namespace aim {
// ===================================================================

class DotCrosshair::_Internal {
 public:
  using HasBits =
      decltype(std::declval<DotCrosshair>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DotCrosshair, _impl_._has_bits_);
};

DotCrosshair::DotCrosshair(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.DotCrosshair)
}
DotCrosshair::DotCrosshair(
    ::google::protobuf::Arena* arena, const DotCrosshair& from)
    : DotCrosshair(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE DotCrosshair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void DotCrosshair::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.outline_thickness_ = {};
}
DotCrosshair::~DotCrosshair() {
  // @@protoc_insertion_point(destructor:aim.DotCrosshair)
  SharedDtor(*this);
}
inline void DotCrosshair::SharedDtor(MessageLite& self) {
  DotCrosshair& this_ = static_cast<DotCrosshair&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* DotCrosshair::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) DotCrosshair(arena);
}
constexpr auto DotCrosshair::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(DotCrosshair),
                                            alignof(DotCrosshair));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull DotCrosshair::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_DotCrosshair_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &DotCrosshair::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<DotCrosshair>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &DotCrosshair::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<DotCrosshair>(), &DotCrosshair::ByteSizeLong,
            &DotCrosshair::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(DotCrosshair, _impl_._cached_size_),
        false,
    },
    &DotCrosshair::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* DotCrosshair::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 0, 2> DotCrosshair::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DotCrosshair, _impl_._has_bits_),
    0, // no _extensions_
    4, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967287,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::DotCrosshair>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float outline_thickness = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 0, 0, PROTOBUF_FIELD_OFFSET(DotCrosshair, _impl_.outline_thickness_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float outline_thickness = 4;
    {PROTOBUF_FIELD_OFFSET(DotCrosshair, _impl_.outline_thickness_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void DotCrosshair::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.DotCrosshair)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.outline_thickness_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* DotCrosshair::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const DotCrosshair& this_ = static_cast<const DotCrosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* DotCrosshair::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const DotCrosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.DotCrosshair)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // float outline_thickness = 4;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                4, this_._internal_outline_thickness(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.DotCrosshair)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t DotCrosshair::ByteSizeLong(const MessageLite& base) {
          const DotCrosshair& this_ = static_cast<const DotCrosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t DotCrosshair::ByteSizeLong() const {
          const DotCrosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.DotCrosshair)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

           {
            // float outline_thickness = 4;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 5;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void DotCrosshair::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<DotCrosshair*>(&to_msg);
  auto& from = static_cast<const DotCrosshair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.DotCrosshair)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_impl_.outline_thickness_ = from._impl_.outline_thickness_;
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DotCrosshair::CopyFrom(const DotCrosshair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.DotCrosshair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DotCrosshair::InternalSwap(DotCrosshair* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
        swap(_impl_.outline_thickness_, other->_impl_.outline_thickness_);
}

::google::protobuf::Metadata DotCrosshair::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class PlusCrosshair::_Internal {
 public:
  using HasBits =
      decltype(std::declval<PlusCrosshair>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_._has_bits_);
};

PlusCrosshair::PlusCrosshair(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.PlusCrosshair)
}
PlusCrosshair::PlusCrosshair(
    ::google::protobuf::Arena* arena, const PlusCrosshair& from)
    : PlusCrosshair(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE PlusCrosshair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void PlusCrosshair::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, rounding_),
           0,
           offsetof(Impl_, horizontal_gap_size_) -
               offsetof(Impl_, rounding_) +
               sizeof(Impl_::horizontal_gap_size_));
}
PlusCrosshair::~PlusCrosshair() {
  // @@protoc_insertion_point(destructor:aim.PlusCrosshair)
  SharedDtor(*this);
}
inline void PlusCrosshair::SharedDtor(MessageLite& self) {
  PlusCrosshair& this_ = static_cast<PlusCrosshair&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* PlusCrosshair::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) PlusCrosshair(arena);
}
constexpr auto PlusCrosshair::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(PlusCrosshair),
                                            alignof(PlusCrosshair));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull PlusCrosshair::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_PlusCrosshair_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &PlusCrosshair::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<PlusCrosshair>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &PlusCrosshair::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<PlusCrosshair>(), &PlusCrosshair::ByteSizeLong,
            &PlusCrosshair::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_._cached_size_),
        false,
    },
    &PlusCrosshair::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* PlusCrosshair::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 0, 0, 2> PlusCrosshair::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::PlusCrosshair>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float rounding = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.rounding_)}},
    // float horizontal_size = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.horizontal_size_)}},
    // float vertical_size = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.vertical_size_)}},
    // float thickness = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.thickness_)}},
    // float outline_thickness = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.outline_thickness_)}},
    // float vertical_gap_size = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 5, 0, PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.vertical_gap_size_)}},
    // float horizontal_gap_size = 7;
    {::_pbi::TcParser::FastF32S1,
     {61, 6, 0, PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.horizontal_gap_size_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float rounding = 1;
    {PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.rounding_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float horizontal_size = 2;
    {PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.horizontal_size_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float vertical_size = 3;
    {PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.vertical_size_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float thickness = 4;
    {PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.thickness_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float outline_thickness = 5;
    {PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.outline_thickness_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float vertical_gap_size = 6;
    {PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.vertical_gap_size_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float horizontal_gap_size = 7;
    {PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.horizontal_gap_size_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void PlusCrosshair::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.PlusCrosshair)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.rounding_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.horizontal_gap_size_) -
        reinterpret_cast<char*>(&_impl_.rounding_)) + sizeof(_impl_.horizontal_gap_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* PlusCrosshair::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const PlusCrosshair& this_ = static_cast<const PlusCrosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* PlusCrosshair::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const PlusCrosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.PlusCrosshair)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // float rounding = 1;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                1, this_._internal_rounding(), target);
          }

          // float horizontal_size = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                2, this_._internal_horizontal_size(), target);
          }

          // float vertical_size = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                3, this_._internal_vertical_size(), target);
          }

          // float thickness = 4;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                4, this_._internal_thickness(), target);
          }

          // float outline_thickness = 5;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                5, this_._internal_outline_thickness(), target);
          }

          // float vertical_gap_size = 6;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                6, this_._internal_vertical_gap_size(), target);
          }

          // float horizontal_gap_size = 7;
          if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                7, this_._internal_horizontal_gap_size(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.PlusCrosshair)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t PlusCrosshair::ByteSizeLong(const MessageLite& base) {
          const PlusCrosshair& this_ = static_cast<const PlusCrosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t PlusCrosshair::ByteSizeLong() const {
          const PlusCrosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.PlusCrosshair)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000007fu) {
            // float rounding = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 5;
            }
            // float horizontal_size = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 5;
            }
            // float vertical_size = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 5;
            }
            // float thickness = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 5;
            }
            // float outline_thickness = 5;
            if (cached_has_bits & 0x00000010u) {
              total_size += 5;
            }
            // float vertical_gap_size = 6;
            if (cached_has_bits & 0x00000020u) {
              total_size += 5;
            }
            // float horizontal_gap_size = 7;
            if (cached_has_bits & 0x00000040u) {
              total_size += 5;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void PlusCrosshair::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<PlusCrosshair*>(&to_msg);
  auto& from = static_cast<const PlusCrosshair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.PlusCrosshair)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.rounding_ = from._impl_.rounding_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.horizontal_size_ = from._impl_.horizontal_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.vertical_size_ = from._impl_.vertical_size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.thickness_ = from._impl_.thickness_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.outline_thickness_ = from._impl_.outline_thickness_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.vertical_gap_size_ = from._impl_.vertical_gap_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.horizontal_gap_size_ = from._impl_.horizontal_gap_size_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void PlusCrosshair::CopyFrom(const PlusCrosshair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.PlusCrosshair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void PlusCrosshair::InternalSwap(PlusCrosshair* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.horizontal_gap_size_)
      + sizeof(PlusCrosshair::_impl_.horizontal_gap_size_)
      - PROTOBUF_FIELD_OFFSET(PlusCrosshair, _impl_.rounding_)>(
          reinterpret_cast<char*>(&_impl_.rounding_),
          reinterpret_cast<char*>(&other->_impl_.rounding_));
}

::google::protobuf::Metadata PlusCrosshair::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CircleCrosshair::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CircleCrosshair>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_._has_bits_);
};

CircleCrosshair::CircleCrosshair(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.CircleCrosshair)
}
CircleCrosshair::CircleCrosshair(
    ::google::protobuf::Arena* arena, const CircleCrosshair& from)
    : CircleCrosshair(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE CircleCrosshair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void CircleCrosshair::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, thickness_),
           0,
           offsetof(Impl_, use_outline_color_) -
               offsetof(Impl_, thickness_) +
               sizeof(Impl_::use_outline_color_));
}
CircleCrosshair::~CircleCrosshair() {
  // @@protoc_insertion_point(destructor:aim.CircleCrosshair)
  SharedDtor(*this);
}
inline void CircleCrosshair::SharedDtor(MessageLite& self) {
  CircleCrosshair& this_ = static_cast<CircleCrosshair&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* CircleCrosshair::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CircleCrosshair(arena);
}
constexpr auto CircleCrosshair::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CircleCrosshair),
                                            alignof(CircleCrosshair));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CircleCrosshair::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CircleCrosshair_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CircleCrosshair::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CircleCrosshair>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CircleCrosshair::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CircleCrosshair>(), &CircleCrosshair::ByteSizeLong,
            &CircleCrosshair::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_._cached_size_),
        false,
    },
    &CircleCrosshair::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CircleCrosshair::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 0, 2> CircleCrosshair::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::CircleCrosshair>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool use_outline_color = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(CircleCrosshair, _impl_.use_outline_color_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_.use_outline_color_)}},
    // float thickness = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 0, 0, PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_.thickness_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float thickness = 1;
    {PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_.thickness_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // bool use_outline_color = 2;
    {PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_.use_outline_color_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void CircleCrosshair::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.CircleCrosshair)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.thickness_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.use_outline_color_) -
        reinterpret_cast<char*>(&_impl_.thickness_)) + sizeof(_impl_.use_outline_color_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CircleCrosshair::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CircleCrosshair& this_ = static_cast<const CircleCrosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CircleCrosshair::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CircleCrosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.CircleCrosshair)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // float thickness = 1;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                1, this_._internal_thickness(), target);
          }

          // bool use_outline_color = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                2, this_._internal_use_outline_color(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.CircleCrosshair)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CircleCrosshair::ByteSizeLong(const MessageLite& base) {
          const CircleCrosshair& this_ = static_cast<const CircleCrosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CircleCrosshair::ByteSizeLong() const {
          const CircleCrosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.CircleCrosshair)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x00000003u) {
            // float thickness = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 5;
            }
            // bool use_outline_color = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 2;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CircleCrosshair::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CircleCrosshair*>(&to_msg);
  auto& from = static_cast<const CircleCrosshair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.CircleCrosshair)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.thickness_ = from._impl_.thickness_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.use_outline_color_ = from._impl_.use_outline_color_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CircleCrosshair::CopyFrom(const CircleCrosshair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.CircleCrosshair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CircleCrosshair::InternalSwap(CircleCrosshair* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_.use_outline_color_)
      + sizeof(CircleCrosshair::_impl_.use_outline_color_)
      - PROTOBUF_FIELD_OFFSET(CircleCrosshair, _impl_.thickness_)>(
          reinterpret_cast<char*>(&_impl_.thickness_),
          reinterpret_cast<char*>(&other->_impl_.thickness_));
}

::google::protobuf::Metadata CircleCrosshair::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ImageCrosshair::_Internal {
 public:
  using HasBits =
      decltype(std::declval<ImageCrosshair>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ImageCrosshair, _impl_._has_bits_);
};

ImageCrosshair::ImageCrosshair(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.ImageCrosshair)
}
inline PROTOBUF_NDEBUG_INLINE ImageCrosshair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::ImageCrosshair& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        file_name_(arena, from.file_name_) {}

ImageCrosshair::ImageCrosshair(
    ::google::protobuf::Arena* arena,
    const ImageCrosshair& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ImageCrosshair* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:aim.ImageCrosshair)
}
inline PROTOBUF_NDEBUG_INLINE ImageCrosshair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        file_name_(arena) {}

inline void ImageCrosshair::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
ImageCrosshair::~ImageCrosshair() {
  // @@protoc_insertion_point(destructor:aim.ImageCrosshair)
  SharedDtor(*this);
}
inline void ImageCrosshair::SharedDtor(MessageLite& self) {
  ImageCrosshair& this_ = static_cast<ImageCrosshair&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.file_name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* ImageCrosshair::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) ImageCrosshair(arena);
}
constexpr auto ImageCrosshair::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ImageCrosshair),
                                            alignof(ImageCrosshair));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull ImageCrosshair::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_ImageCrosshair_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &ImageCrosshair::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<ImageCrosshair>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &ImageCrosshair::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<ImageCrosshair>(), &ImageCrosshair::ByteSizeLong,
            &ImageCrosshair::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(ImageCrosshair, _impl_._cached_size_),
        false,
    },
    &ImageCrosshair::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* ImageCrosshair::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 0, 36, 2> ImageCrosshair::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ImageCrosshair, _impl_._has_bits_),
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::ImageCrosshair>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string file_name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(ImageCrosshair, _impl_.file_name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string file_name = 1;
    {PROTOBUF_FIELD_OFFSET(ImageCrosshair, _impl_.file_name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\22\11\0\0\0\0\0\0"
    "aim.ImageCrosshair"
    "file_name"
  }},
};

PROTOBUF_NOINLINE void ImageCrosshair::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.ImageCrosshair)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.file_name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* ImageCrosshair::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const ImageCrosshair& this_ = static_cast<const ImageCrosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* ImageCrosshair::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const ImageCrosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.ImageCrosshair)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // string file_name = 1;
          if (cached_has_bits & 0x00000001u) {
            const std::string& _s = this_._internal_file_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.ImageCrosshair.file_name");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.ImageCrosshair)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t ImageCrosshair::ByteSizeLong(const MessageLite& base) {
          const ImageCrosshair& this_ = static_cast<const ImageCrosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t ImageCrosshair::ByteSizeLong() const {
          const ImageCrosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.ImageCrosshair)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

           {
            // string file_name = 1;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_file_name());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void ImageCrosshair::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ImageCrosshair*>(&to_msg);
  auto& from = static_cast<const ImageCrosshair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.ImageCrosshair)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_internal_set_file_name(from._internal_file_name());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ImageCrosshair::CopyFrom(const ImageCrosshair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.ImageCrosshair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ImageCrosshair::InternalSwap(ImageCrosshair* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.file_name_, &other->_impl_.file_name_, arena);
}

::google::protobuf::Metadata ImageCrosshair::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class CrosshairLayer::_Internal {
 public:
  using HasBits =
      decltype(std::declval<CrosshairLayer>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::aim::CrosshairLayer, _impl_._oneof_case_);
};

void CrosshairLayer::clear_override_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.override_color_ != nullptr) _impl_.override_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CrosshairLayer::clear_override_outline_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.override_outline_color_ != nullptr) _impl_.override_outline_color_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CrosshairLayer::set_allocated_dot(::aim::DotCrosshair* dot) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (dot) {
    ::google::protobuf::Arena* submessage_arena = dot->GetArena();
    if (message_arena != submessage_arena) {
      dot = ::google::protobuf::internal::GetOwnedMessage(message_arena, dot, submessage_arena);
    }
    set_has_dot();
    _impl_.type_.dot_ = dot;
  }
  // @@protoc_insertion_point(field_set_allocated:aim.CrosshairLayer.dot)
}
void CrosshairLayer::set_allocated_plus(::aim::PlusCrosshair* plus) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (plus) {
    ::google::protobuf::Arena* submessage_arena = plus->GetArena();
    if (message_arena != submessage_arena) {
      plus = ::google::protobuf::internal::GetOwnedMessage(message_arena, plus, submessage_arena);
    }
    set_has_plus();
    _impl_.type_.plus_ = plus;
  }
  // @@protoc_insertion_point(field_set_allocated:aim.CrosshairLayer.plus)
}
void CrosshairLayer::set_allocated_image(::aim::ImageCrosshair* image) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (image) {
    ::google::protobuf::Arena* submessage_arena = image->GetArena();
    if (message_arena != submessage_arena) {
      image = ::google::protobuf::internal::GetOwnedMessage(message_arena, image, submessage_arena);
    }
    set_has_image();
    _impl_.type_.image_ = image;
  }
  // @@protoc_insertion_point(field_set_allocated:aim.CrosshairLayer.image)
}
void CrosshairLayer::set_allocated_circle(::aim::CircleCrosshair* circle) {
  ::google::protobuf::Arena* message_arena = GetArena();
  clear_type();
  if (circle) {
    ::google::protobuf::Arena* submessage_arena = circle->GetArena();
    if (message_arena != submessage_arena) {
      circle = ::google::protobuf::internal::GetOwnedMessage(message_arena, circle, submessage_arena);
    }
    set_has_circle();
    _impl_.type_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_set_allocated:aim.CrosshairLayer.circle)
}
CrosshairLayer::CrosshairLayer(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.CrosshairLayer)
}
inline PROTOBUF_NDEBUG_INLINE CrosshairLayer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::CrosshairLayer& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        type_{},
        _oneof_case_{from._oneof_case_[0]} {}

CrosshairLayer::CrosshairLayer(
    ::google::protobuf::Arena* arena,
    const CrosshairLayer& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  CrosshairLayer* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.override_color_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::aim::StoredColor>(
                              arena, *from._impl_.override_color_)
                        : nullptr;
  _impl_.override_outline_color_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::aim::StoredColor>(
                              arena, *from._impl_.override_outline_color_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, scale_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, scale_),
           offsetof(Impl_, alpha_) -
               offsetof(Impl_, scale_) +
               sizeof(Impl_::alpha_));
  switch (type_case()) {
    case TYPE_NOT_SET:
      break;
      case kDot:
        _impl_.type_.dot_ = ::google::protobuf::Message::CopyConstruct<::aim::DotCrosshair>(arena, *from._impl_.type_.dot_);
        break;
      case kPlus:
        _impl_.type_.plus_ = ::google::protobuf::Message::CopyConstruct<::aim::PlusCrosshair>(arena, *from._impl_.type_.plus_);
        break;
      case kImage:
        _impl_.type_.image_ = ::google::protobuf::Message::CopyConstruct<::aim::ImageCrosshair>(arena, *from._impl_.type_.image_);
        break;
      case kCircle:
        _impl_.type_.circle_ = ::google::protobuf::Message::CopyConstruct<::aim::CircleCrosshair>(arena, *from._impl_.type_.circle_);
        break;
  }

  // @@protoc_insertion_point(copy_constructor:aim.CrosshairLayer)
}
inline PROTOBUF_NDEBUG_INLINE CrosshairLayer::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        type_{},
        _oneof_case_{} {}

inline void CrosshairLayer::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, override_color_),
           0,
           offsetof(Impl_, alpha_) -
               offsetof(Impl_, override_color_) +
               sizeof(Impl_::alpha_));
}
CrosshairLayer::~CrosshairLayer() {
  // @@protoc_insertion_point(destructor:aim.CrosshairLayer)
  SharedDtor(*this);
}
inline void CrosshairLayer::SharedDtor(MessageLite& self) {
  CrosshairLayer& this_ = static_cast<CrosshairLayer&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.override_color_;
  delete this_._impl_.override_outline_color_;
  if (this_.has_type()) {
    this_.clear_type();
  }
  this_._impl_.~Impl_();
}

void CrosshairLayer::clear_type() {
// @@protoc_insertion_point(one_of_clear_start:aim.CrosshairLayer)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (type_case()) {
    case kDot: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.dot_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.dot_);
      }
      break;
    }
    case kPlus: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.plus_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.plus_);
      }
      break;
    }
    case kImage: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.image_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.image_);
      }
      break;
    }
    case kCircle: {
      if (GetArena() == nullptr) {
        delete _impl_.type_.circle_;
      } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
        ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.type_.circle_);
      }
      break;
    }
    case TYPE_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}


inline void* CrosshairLayer::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) CrosshairLayer(arena);
}
constexpr auto CrosshairLayer::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(CrosshairLayer),
                                            alignof(CrosshairLayer));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull CrosshairLayer::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_CrosshairLayer_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &CrosshairLayer::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<CrosshairLayer>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &CrosshairLayer::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<CrosshairLayer>(), &CrosshairLayer::ByteSizeLong,
            &CrosshairLayer::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_._cached_size_),
        false,
    },
    &CrosshairLayer::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* CrosshairLayer::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 8, 6, 0, 2> CrosshairLayer::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_._has_bits_),
    0, // no _extensions_
    13, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294959600,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    6,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::CrosshairLayer>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float alpha = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.alpha_)}},
    // .aim.StoredColor override_color = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.override_color_)}},
    // .aim.StoredColor override_outline_color = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.override_outline_color_)}},
    // float scale = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.scale_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .aim.StoredColor override_color = 1;
    {PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.override_color_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.StoredColor override_outline_color = 2;
    {PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.override_outline_color_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // float scale = 3;
    {PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.scale_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float alpha = 4;
    {PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.alpha_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // .aim.DotCrosshair dot = 10;
    {PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.type_.dot_), _Internal::kOneofCaseOffset + 0, 2,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.PlusCrosshair plus = 11;
    {PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.type_.plus_), _Internal::kOneofCaseOffset + 0, 3,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.ImageCrosshair image = 12;
    {PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.type_.image_), _Internal::kOneofCaseOffset + 0, 4,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.CircleCrosshair circle = 13;
    {PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.type_.circle_), _Internal::kOneofCaseOffset + 0, 5,
    (0 | ::_fl::kFcOneof | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::aim::StoredColor>()},
    {::_pbi::TcParser::GetTable<::aim::StoredColor>()},
    {::_pbi::TcParser::GetTable<::aim::DotCrosshair>()},
    {::_pbi::TcParser::GetTable<::aim::PlusCrosshair>()},
    {::_pbi::TcParser::GetTable<::aim::ImageCrosshair>()},
    {::_pbi::TcParser::GetTable<::aim::CircleCrosshair>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void CrosshairLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.CrosshairLayer)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.override_color_ != nullptr);
      _impl_.override_color_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.override_outline_color_ != nullptr);
      _impl_.override_outline_color_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.scale_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.alpha_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.alpha_));
  }
  clear_type();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* CrosshairLayer::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const CrosshairLayer& this_ = static_cast<const CrosshairLayer&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* CrosshairLayer::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const CrosshairLayer& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.CrosshairLayer)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .aim.StoredColor override_color = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.override_color_, this_._impl_.override_color_->GetCachedSize(), target,
                stream);
          }

          // .aim.StoredColor override_outline_color = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.override_outline_color_, this_._impl_.override_outline_color_->GetCachedSize(), target,
                stream);
          }

          // float scale = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                3, this_._internal_scale(), target);
          }

          // float alpha = 4;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                4, this_._internal_alpha(), target);
          }

          switch (this_.type_case()) {
            case kDot: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  10, *this_._impl_.type_.dot_, this_._impl_.type_.dot_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kPlus: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  11, *this_._impl_.type_.plus_, this_._impl_.type_.plus_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kImage: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  12, *this_._impl_.type_.image_, this_._impl_.type_.image_->GetCachedSize(), target,
                  stream);
              break;
            }
            case kCircle: {
              target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                  13, *this_._impl_.type_.circle_, this_._impl_.type_.circle_->GetCachedSize(), target,
                  stream);
              break;
            }
            default:
              break;
          }
          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.CrosshairLayer)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t CrosshairLayer::ByteSizeLong(const MessageLite& base) {
          const CrosshairLayer& this_ = static_cast<const CrosshairLayer&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t CrosshairLayer::ByteSizeLong() const {
          const CrosshairLayer& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.CrosshairLayer)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000000fu) {
            // .aim.StoredColor override_color = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.override_color_);
            }
            // .aim.StoredColor override_outline_color = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.override_outline_color_);
            }
            // float scale = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 5;
            }
            // float alpha = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 5;
            }
          }
          switch (this_.type_case()) {
            // .aim.DotCrosshair dot = 10;
            case kDot: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.dot_);
              break;
            }
            // .aim.PlusCrosshair plus = 11;
            case kPlus: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.plus_);
              break;
            }
            // .aim.ImageCrosshair image = 12;
            case kImage: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.image_);
              break;
            }
            // .aim.CircleCrosshair circle = 13;
            case kCircle: {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.type_.circle_);
              break;
            }
            case TYPE_NOT_SET: {
              break;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void CrosshairLayer::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<CrosshairLayer*>(&to_msg);
  auto& from = static_cast<const CrosshairLayer&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.CrosshairLayer)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.override_color_ != nullptr);
      if (_this->_impl_.override_color_ == nullptr) {
        _this->_impl_.override_color_ =
            ::google::protobuf::Message::CopyConstruct<::aim::StoredColor>(arena, *from._impl_.override_color_);
      } else {
        _this->_impl_.override_color_->MergeFrom(*from._impl_.override_color_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.override_outline_color_ != nullptr);
      if (_this->_impl_.override_outline_color_ == nullptr) {
        _this->_impl_.override_outline_color_ =
            ::google::protobuf::Message::CopyConstruct<::aim::StoredColor>(arena, *from._impl_.override_outline_color_);
      } else {
        _this->_impl_.override_outline_color_->MergeFrom(*from._impl_.override_outline_color_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.alpha_ = from._impl_.alpha_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_type();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kDot: {
        if (oneof_needs_init) {
          _this->_impl_.type_.dot_ =
              ::google::protobuf::Message::CopyConstruct<::aim::DotCrosshair>(arena, *from._impl_.type_.dot_);
        } else {
          _this->_impl_.type_.dot_->MergeFrom(from._internal_dot());
        }
        break;
      }
      case kPlus: {
        if (oneof_needs_init) {
          _this->_impl_.type_.plus_ =
              ::google::protobuf::Message::CopyConstruct<::aim::PlusCrosshair>(arena, *from._impl_.type_.plus_);
        } else {
          _this->_impl_.type_.plus_->MergeFrom(from._internal_plus());
        }
        break;
      }
      case kImage: {
        if (oneof_needs_init) {
          _this->_impl_.type_.image_ =
              ::google::protobuf::Message::CopyConstruct<::aim::ImageCrosshair>(arena, *from._impl_.type_.image_);
        } else {
          _this->_impl_.type_.image_->MergeFrom(from._internal_image());
        }
        break;
      }
      case kCircle: {
        if (oneof_needs_init) {
          _this->_impl_.type_.circle_ =
              ::google::protobuf::Message::CopyConstruct<::aim::CircleCrosshair>(arena, *from._impl_.type_.circle_);
        } else {
          _this->_impl_.type_.circle_->MergeFrom(from._internal_circle());
        }
        break;
      }
      case TYPE_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void CrosshairLayer::CopyFrom(const CrosshairLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.CrosshairLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void CrosshairLayer::InternalSwap(CrosshairLayer* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.alpha_)
      + sizeof(CrosshairLayer::_impl_.alpha_)
      - PROTOBUF_FIELD_OFFSET(CrosshairLayer, _impl_.override_color_)>(
          reinterpret_cast<char*>(&_impl_.override_color_),
          reinterpret_cast<char*>(&other->_impl_.override_color_));
  swap(_impl_.type_, other->_impl_.type_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata CrosshairLayer::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Crosshair::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Crosshair>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Crosshair, _impl_._has_bits_);
};

Crosshair::Crosshair(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.Crosshair)
}
inline PROTOBUF_NDEBUG_INLINE Crosshair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::Crosshair& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        layers_{visibility, arena, from.layers_},
        name_(arena, from.name_) {}

Crosshair::Crosshair(
    ::google::protobuf::Arena* arena,
    const Crosshair& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Crosshair* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:aim.Crosshair)
}
inline PROTOBUF_NDEBUG_INLINE Crosshair::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        layers_{visibility, arena},
        name_(arena) {}

inline void Crosshair::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
Crosshair::~Crosshair() {
  // @@protoc_insertion_point(destructor:aim.Crosshair)
  SharedDtor(*this);
}
inline void Crosshair::SharedDtor(MessageLite& self) {
  Crosshair& this_ = static_cast<Crosshair&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.name_.Destroy();
  this_._impl_.~Impl_();
}

inline void* Crosshair::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Crosshair(arena);
}
constexpr auto Crosshair::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Crosshair, _impl_.layers_) +
          decltype(Crosshair::_impl_.layers_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(Crosshair), alignof(Crosshair), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Crosshair::PlacementNew_,
                                 sizeof(Crosshair),
                                 alignof(Crosshair));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Crosshair::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Crosshair_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Crosshair::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Crosshair>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Crosshair::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Crosshair>(), &Crosshair::ByteSizeLong,
            &Crosshair::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Crosshair, _impl_._cached_size_),
        false,
    },
    &Crosshair::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Crosshair::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 1, 26, 2> Crosshair::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Crosshair, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::Crosshair>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .aim.CrosshairLayer layers = 2;
    {::_pbi::TcParser::FastMtR1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(Crosshair, _impl_.layers_)}},
    // string name = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Crosshair, _impl_.name_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string name = 1;
    {PROTOBUF_FIELD_OFFSET(Crosshair, _impl_.name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .aim.CrosshairLayer layers = 2;
    {PROTOBUF_FIELD_OFFSET(Crosshair, _impl_.layers_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::aim::CrosshairLayer>()},
  }}, {{
    "\15\4\0\0\0\0\0\0"
    "aim.Crosshair"
    "name"
  }},
};

PROTOBUF_NOINLINE void Crosshair::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.Crosshair)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Crosshair::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Crosshair& this_ = static_cast<const Crosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Crosshair::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Crosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.Crosshair)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // string name = 1;
          if (cached_has_bits & 0x00000001u) {
            const std::string& _s = this_._internal_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.Crosshair.name");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // repeated .aim.CrosshairLayer layers = 2;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_layers_size());
               i < n; i++) {
            const auto& repfield = this_._internal_layers().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    2, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.Crosshair)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Crosshair::ByteSizeLong(const MessageLite& base) {
          const Crosshair& this_ = static_cast<const Crosshair&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Crosshair::ByteSizeLong() const {
          const Crosshair& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.Crosshair)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .aim.CrosshairLayer layers = 2;
            {
              total_size += 1UL * this_._internal_layers_size();
              for (const auto& msg : this_._internal_layers()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
           {
            // string name = 1;
            cached_has_bits = this_._impl_._has_bits_[0];
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_name());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Crosshair::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Crosshair*>(&to_msg);
  auto& from = static_cast<const Crosshair&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.Crosshair)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_layers()->MergeFrom(
      from._internal_layers());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Crosshair::CopyFrom(const Crosshair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.Crosshair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Crosshair::InternalSwap(Crosshair* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.layers_.InternalSwap(&other->_impl_.layers_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.name_, &other->_impl_.name_, arena);
}

::google::protobuf::Metadata Crosshair::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class HealthBarSettings::_Internal {
 public:
  using HasBits =
      decltype(std::declval<HealthBarSettings>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_._has_bits_);
};

HealthBarSettings::HealthBarSettings(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.HealthBarSettings)
}
HealthBarSettings::HealthBarSettings(
    ::google::protobuf::Arena* arena, const HealthBarSettings& from)
    : HealthBarSettings(arena) {
  MergeFrom(from);
}
inline PROTOBUF_NDEBUG_INLINE HealthBarSettings::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void HealthBarSettings::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, show_),
           0,
           offsetof(Impl_, height_above_target_) -
               offsetof(Impl_, show_) +
               sizeof(Impl_::height_above_target_));
}
HealthBarSettings::~HealthBarSettings() {
  // @@protoc_insertion_point(destructor:aim.HealthBarSettings)
  SharedDtor(*this);
}
inline void HealthBarSettings::SharedDtor(MessageLite& self) {
  HealthBarSettings& this_ = static_cast<HealthBarSettings&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* HealthBarSettings::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) HealthBarSettings(arena);
}
constexpr auto HealthBarSettings::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(HealthBarSettings),
                                            alignof(HealthBarSettings));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull HealthBarSettings::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_HealthBarSettings_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &HealthBarSettings::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<HealthBarSettings>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &HealthBarSettings::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<HealthBarSettings>(), &HealthBarSettings::ByteSizeLong,
            &HealthBarSettings::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_._cached_size_),
        false,
    },
    &HealthBarSettings::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* HealthBarSettings::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 5, 0, 0, 2> HealthBarSettings::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_._has_bits_),
    0, // no _extensions_
    5, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967264,  // skipmap
    offsetof(decltype(_table_), field_entries),
    5,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::HealthBarSettings>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // bool show = 1;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(HealthBarSettings, _impl_.show_), 0>(),
     {8, 0, 0, PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.show_)}},
    // bool only_damaged = 2;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(HealthBarSettings, _impl_.only_damaged_), 1>(),
     {16, 1, 0, PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.only_damaged_)}},
    // float height = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 2, 0, PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.height_)}},
    // float width = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 3, 0, PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.width_)}},
    // float height_above_target = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 4, 0, PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.height_above_target_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // bool show = 1;
    {PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.show_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool only_damaged = 2;
    {PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.only_damaged_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // float height = 3;
    {PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.height_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float width = 4;
    {PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.width_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float height_above_target = 5;
    {PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.height_above_target_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
  }},
};

PROTOBUF_NOINLINE void HealthBarSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.HealthBarSettings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.show_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.height_above_target_) -
        reinterpret_cast<char*>(&_impl_.show_)) + sizeof(_impl_.height_above_target_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* HealthBarSettings::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const HealthBarSettings& this_ = static_cast<const HealthBarSettings&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* HealthBarSettings::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const HealthBarSettings& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.HealthBarSettings)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // bool show = 1;
          if (cached_has_bits & 0x00000001u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                1, this_._internal_show(), target);
          }

          // bool only_damaged = 2;
          if (cached_has_bits & 0x00000002u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                2, this_._internal_only_damaged(), target);
          }

          // float height = 3;
          if (cached_has_bits & 0x00000004u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                3, this_._internal_height(), target);
          }

          // float width = 4;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                4, this_._internal_width(), target);
          }

          // float height_above_target = 5;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                5, this_._internal_height_above_target(), target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.HealthBarSettings)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t HealthBarSettings::ByteSizeLong(const MessageLite& base) {
          const HealthBarSettings& this_ = static_cast<const HealthBarSettings&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t HealthBarSettings::ByteSizeLong() const {
          const HealthBarSettings& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.HealthBarSettings)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000001fu) {
            // bool show = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 2;
            }
            // bool only_damaged = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 2;
            }
            // float height = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 5;
            }
            // float width = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 5;
            }
            // float height_above_target = 5;
            if (cached_has_bits & 0x00000010u) {
              total_size += 5;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void HealthBarSettings::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<HealthBarSettings*>(&to_msg);
  auto& from = static_cast<const HealthBarSettings&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.HealthBarSettings)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.show_ = from._impl_.show_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.only_damaged_ = from._impl_.only_damaged_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.height_above_target_ = from._impl_.height_above_target_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void HealthBarSettings::CopyFrom(const HealthBarSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.HealthBarSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void HealthBarSettings::InternalSwap(HealthBarSettings* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.height_above_target_)
      + sizeof(HealthBarSettings::_impl_.height_above_target_)
      - PROTOBUF_FIELD_OFFSET(HealthBarSettings, _impl_.show_)>(
          reinterpret_cast<char*>(&_impl_.show_),
          reinterpret_cast<char*>(&other->_impl_.show_));
}

::google::protobuf::Metadata HealthBarSettings::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SavedCrosshairs::_Internal {
 public:
};

SavedCrosshairs::SavedCrosshairs(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.SavedCrosshairs)
}
inline PROTOBUF_NDEBUG_INLINE SavedCrosshairs::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::SavedCrosshairs& from_msg)
      : crosshairs_{visibility, arena, from.crosshairs_},
        _cached_size_{0} {}

SavedCrosshairs::SavedCrosshairs(
    ::google::protobuf::Arena* arena,
    const SavedCrosshairs& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SavedCrosshairs* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:aim.SavedCrosshairs)
}
inline PROTOBUF_NDEBUG_INLINE SavedCrosshairs::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : crosshairs_{visibility, arena},
        _cached_size_{0} {}

inline void SavedCrosshairs::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
SavedCrosshairs::~SavedCrosshairs() {
  // @@protoc_insertion_point(destructor:aim.SavedCrosshairs)
  SharedDtor(*this);
}
inline void SavedCrosshairs::SharedDtor(MessageLite& self) {
  SavedCrosshairs& this_ = static_cast<SavedCrosshairs&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.~Impl_();
}

inline void* SavedCrosshairs::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) SavedCrosshairs(arena);
}
constexpr auto SavedCrosshairs::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(SavedCrosshairs, _impl_.crosshairs_) +
          decltype(SavedCrosshairs::_impl_.crosshairs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::ZeroInit(
        sizeof(SavedCrosshairs), alignof(SavedCrosshairs), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&SavedCrosshairs::PlacementNew_,
                                 sizeof(SavedCrosshairs),
                                 alignof(SavedCrosshairs));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull SavedCrosshairs::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_SavedCrosshairs_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &SavedCrosshairs::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<SavedCrosshairs>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &SavedCrosshairs::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<SavedCrosshairs>(), &SavedCrosshairs::ByteSizeLong,
            &SavedCrosshairs::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(SavedCrosshairs, _impl_._cached_size_),
        false,
    },
    &SavedCrosshairs::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* SavedCrosshairs::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<0, 1, 1, 0, 2> SavedCrosshairs::_table_ = {
  {
    0,  // no _has_bits_
    0, // no _extensions_
    1, 0,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967294,  // skipmap
    offsetof(decltype(_table_), field_entries),
    1,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::SavedCrosshairs>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // repeated .aim.Crosshair crosshairs = 1;
    {::_pbi::TcParser::FastMtR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(SavedCrosshairs, _impl_.crosshairs_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated .aim.Crosshair crosshairs = 1;
    {PROTOBUF_FIELD_OFFSET(SavedCrosshairs, _impl_.crosshairs_), 0, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::aim::Crosshair>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void SavedCrosshairs::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.SavedCrosshairs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.crosshairs_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* SavedCrosshairs::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const SavedCrosshairs& this_ = static_cast<const SavedCrosshairs&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* SavedCrosshairs::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const SavedCrosshairs& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.SavedCrosshairs)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          // repeated .aim.Crosshair crosshairs = 1;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_crosshairs_size());
               i < n; i++) {
            const auto& repfield = this_._internal_crosshairs().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    1, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.SavedCrosshairs)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t SavedCrosshairs::ByteSizeLong(const MessageLite& base) {
          const SavedCrosshairs& this_ = static_cast<const SavedCrosshairs&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t SavedCrosshairs::ByteSizeLong() const {
          const SavedCrosshairs& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.SavedCrosshairs)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .aim.Crosshair crosshairs = 1;
            {
              total_size += 1UL * this_._internal_crosshairs_size();
              for (const auto& msg : this_._internal_crosshairs()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void SavedCrosshairs::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SavedCrosshairs*>(&to_msg);
  auto& from = static_cast<const SavedCrosshairs&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.SavedCrosshairs)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_crosshairs()->MergeFrom(
      from._internal_crosshairs());
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SavedCrosshairs::CopyFrom(const SavedCrosshairs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.SavedCrosshairs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SavedCrosshairs::InternalSwap(SavedCrosshairs* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.crosshairs_.InternalSwap(&other->_impl_.crosshairs_);
}

::google::protobuf::Metadata SavedCrosshairs::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Settings::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Settings>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Settings, _impl_._has_bits_);
};

Settings::Settings(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.Settings)
}
inline PROTOBUF_NDEBUG_INLINE Settings::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::Settings& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        saved_crosshairs_{visibility, arena, from.saved_crosshairs_},
        theme_name_(arena, from.theme_name_),
        current_crosshair_name_(arena, from.current_crosshair_name_) {}

Settings::Settings(
    ::google::protobuf::Arena* arena,
    const Settings& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Settings* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.keybinds_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::aim::Keybinds>(
                              arena, *from._impl_.keybinds_)
                        : nullptr;
  _impl_.health_bar_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::aim::HealthBarSettings>(
                              arena, *from._impl_.health_bar_)
                        : nullptr;
  _impl_.sound_ = (cached_has_bits & 0x00000010u) ? ::google::protobuf::Message::CopyConstruct<::aim::SoundSettings>(
                              arena, *from._impl_.sound_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, dpi_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, dpi_),
           offsetof(Impl_, max_render_fps_) -
               offsetof(Impl_, dpi_) +
               sizeof(Impl_::max_render_fps_));

  // @@protoc_insertion_point(copy_constructor:aim.Settings)
}
inline PROTOBUF_NDEBUG_INLINE Settings::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        saved_crosshairs_{visibility, arena},
        theme_name_(arena),
        current_crosshair_name_(arena) {}

inline void Settings::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, keybinds_),
           0,
           offsetof(Impl_, max_render_fps_) -
               offsetof(Impl_, keybinds_) +
               sizeof(Impl_::max_render_fps_));
}
Settings::~Settings() {
  // @@protoc_insertion_point(destructor:aim.Settings)
  SharedDtor(*this);
}
inline void Settings::SharedDtor(MessageLite& self) {
  Settings& this_ = static_cast<Settings&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.theme_name_.Destroy();
  this_._impl_.current_crosshair_name_.Destroy();
  delete this_._impl_.keybinds_;
  delete this_._impl_.health_bar_;
  delete this_._impl_.sound_;
  this_._impl_.~Impl_();
}

inline void* Settings::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Settings(arena);
}
constexpr auto Settings::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(Settings, _impl_.saved_crosshairs_) +
          decltype(Settings::_impl_.saved_crosshairs_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(Settings), alignof(Settings), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&Settings::PlacementNew_,
                                 sizeof(Settings),
                                 alignof(Settings));
  }
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Settings::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Settings_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Settings::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Settings>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Settings::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Settings>(), &Settings::ByteSizeLong,
            &Settings::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Settings, _impl_._cached_size_),
        false,
    },
    &Settings::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Settings::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 4, 61, 2> Settings::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Settings, _impl_._has_bits_),
    0, // no _extensions_
    15, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294934528,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::Settings>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // float dpi = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 5, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.dpi_)}},
    // float cm_per_360 = 2;
    {::_pbi::TcParser::FastF32S1,
     {21, 6, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.cm_per_360_)}},
    // string theme_name = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 0, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.theme_name_)}},
    // float metronome_bpm = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 7, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.metronome_bpm_)}},
    // float crosshair_size = 5;
    {::_pbi::TcParser::FastF32S1,
     {45, 8, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.crosshair_size_)}},
    // string current_crosshair_name = 6;
    {::_pbi::TcParser::FastUS1,
     {50, 1, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.current_crosshair_name_)}},
    // repeated .aim.Crosshair saved_crosshairs = 7;
    {::_pbi::TcParser::FastMtR1,
     {58, 63, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.saved_crosshairs_)}},
    // bool disable_click_to_start = 8;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Settings, _impl_.disable_click_to_start_), 9>(),
     {64, 9, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.disable_click_to_start_)}},
    // .aim.Keybinds keybinds = 9;
    {::_pbi::TcParser::FastMtS1,
     {74, 2, 1, PROTOBUF_FIELD_OFFSET(Settings, _impl_.keybinds_)}},
    // bool auto_hold_tracking = 10;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Settings, _impl_.auto_hold_tracking_), 10>(),
     {80, 10, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.auto_hold_tracking_)}},
    // float cm_per_360_jitter = 11;
    {::_pbi::TcParser::FastF32S1,
     {93, 12, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.cm_per_360_jitter_)}},
    // .aim.HealthBarSettings health_bar = 12;
    {::_pbi::TcParser::FastMtS1,
     {98, 3, 2, PROTOBUF_FIELD_OFFSET(Settings, _impl_.health_bar_)}},
    // bool disable_per_scenario_settings = 13;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(Settings, _impl_.disable_per_scenario_settings_), 11>(),
     {104, 11, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.disable_per_scenario_settings_)}},
    // float max_render_fps = 14;
    {::_pbi::TcParser::FastF32S1,
     {117, 13, 0, PROTOBUF_FIELD_OFFSET(Settings, _impl_.max_render_fps_)}},
    // .aim.SoundSettings sound = 15;
    {::_pbi::TcParser::FastMtS1,
     {122, 4, 3, PROTOBUF_FIELD_OFFSET(Settings, _impl_.sound_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float dpi = 1;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.dpi_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float cm_per_360 = 2;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.cm_per_360_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // string theme_name = 3;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.theme_name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float metronome_bpm = 4;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.metronome_bpm_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float crosshair_size = 5;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.crosshair_size_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // string current_crosshair_name = 6;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.current_crosshair_name_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated .aim.Crosshair saved_crosshairs = 7;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.saved_crosshairs_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool disable_click_to_start = 8;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.disable_click_to_start_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .aim.Keybinds keybinds = 9;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.keybinds_), _Internal::kHasBitsOffset + 2, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool auto_hold_tracking = 10;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.auto_hold_tracking_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // float cm_per_360_jitter = 11;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.cm_per_360_jitter_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // .aim.HealthBarSettings health_bar = 12;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.health_bar_), _Internal::kHasBitsOffset + 3, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // bool disable_per_scenario_settings = 13;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.disable_per_scenario_settings_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // float max_render_fps = 14;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.max_render_fps_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // .aim.SoundSettings sound = 15;
    {PROTOBUF_FIELD_OFFSET(Settings, _impl_.sound_), _Internal::kHasBitsOffset + 4, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::aim::Crosshair>()},
    {::_pbi::TcParser::GetTable<::aim::Keybinds>()},
    {::_pbi::TcParser::GetTable<::aim::HealthBarSettings>()},
    {::_pbi::TcParser::GetTable<::aim::SoundSettings>()},
  }}, {{
    "\14\0\0\12\0\0\26\0\0\0\0\0\0\0\0\0"
    "aim.Settings"
    "theme_name"
    "current_crosshair_name"
  }},
};

PROTOBUF_NOINLINE void Settings::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.Settings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.saved_crosshairs_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.theme_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.current_crosshair_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.keybinds_ != nullptr);
      _impl_.keybinds_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.health_bar_ != nullptr);
      _impl_.health_bar_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.sound_ != nullptr);
      _impl_.sound_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.dpi_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.metronome_bpm_) -
        reinterpret_cast<char*>(&_impl_.dpi_)) + sizeof(_impl_.metronome_bpm_));
  }
  if (cached_has_bits & 0x00003f00u) {
    ::memset(&_impl_.crosshair_size_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_render_fps_) -
        reinterpret_cast<char*>(&_impl_.crosshair_size_)) + sizeof(_impl_.max_render_fps_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Settings::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Settings& this_ = static_cast<const Settings&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Settings::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Settings& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.Settings)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // float dpi = 1;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                1, this_._internal_dpi(), target);
          }

          // float cm_per_360 = 2;
          if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                2, this_._internal_cm_per_360(), target);
          }

          // string theme_name = 3;
          if (cached_has_bits & 0x00000001u) {
            const std::string& _s = this_._internal_theme_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.Settings.theme_name");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          // float metronome_bpm = 4;
          if (cached_has_bits & 0x00000080u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                4, this_._internal_metronome_bpm(), target);
          }

          // float crosshair_size = 5;
          if (cached_has_bits & 0x00000100u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                5, this_._internal_crosshair_size(), target);
          }

          // string current_crosshair_name = 6;
          if (cached_has_bits & 0x00000002u) {
            const std::string& _s = this_._internal_current_crosshair_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.Settings.current_crosshair_name");
            target = stream->WriteStringMaybeAliased(6, _s, target);
          }

          // repeated .aim.Crosshair saved_crosshairs = 7;
          for (unsigned i = 0, n = static_cast<unsigned>(
                                   this_._internal_saved_crosshairs_size());
               i < n; i++) {
            const auto& repfield = this_._internal_saved_crosshairs().Get(i);
            target =
                ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                    7, repfield, repfield.GetCachedSize(),
                    target, stream);
          }

          // bool disable_click_to_start = 8;
          if (cached_has_bits & 0x00000200u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                8, this_._internal_disable_click_to_start(), target);
          }

          // .aim.Keybinds keybinds = 9;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                9, *this_._impl_.keybinds_, this_._impl_.keybinds_->GetCachedSize(), target,
                stream);
          }

          // bool auto_hold_tracking = 10;
          if (cached_has_bits & 0x00000400u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                10, this_._internal_auto_hold_tracking(), target);
          }

          // float cm_per_360_jitter = 11;
          if (cached_has_bits & 0x00001000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                11, this_._internal_cm_per_360_jitter(), target);
          }

          // .aim.HealthBarSettings health_bar = 12;
          if (cached_has_bits & 0x00000008u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                12, *this_._impl_.health_bar_, this_._impl_.health_bar_->GetCachedSize(), target,
                stream);
          }

          // bool disable_per_scenario_settings = 13;
          if (cached_has_bits & 0x00000800u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                13, this_._internal_disable_per_scenario_settings(), target);
          }

          // float max_render_fps = 14;
          if (cached_has_bits & 0x00002000u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                14, this_._internal_max_render_fps(), target);
          }

          // .aim.SoundSettings sound = 15;
          if (cached_has_bits & 0x00000010u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                15, *this_._impl_.sound_, this_._impl_.sound_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.Settings)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Settings::ByteSizeLong(const MessageLite& base) {
          const Settings& this_ = static_cast<const Settings&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Settings::ByteSizeLong() const {
          const Settings& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.Settings)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
           {
            // repeated .aim.Crosshair saved_crosshairs = 7;
            {
              total_size += 1UL * this_._internal_saved_crosshairs_size();
              for (const auto& msg : this_._internal_saved_crosshairs()) {
                total_size += ::google::protobuf::internal::WireFormatLite::MessageSize(msg);
              }
            }
          }
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x000000ffu) {
            // string theme_name = 3;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_theme_name());
            }
            // string current_crosshair_name = 6;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_current_crosshair_name());
            }
            // .aim.Keybinds keybinds = 9;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.keybinds_);
            }
            // .aim.HealthBarSettings health_bar = 12;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.health_bar_);
            }
            // .aim.SoundSettings sound = 15;
            if (cached_has_bits & 0x00000010u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.sound_);
            }
            // float dpi = 1;
            if (cached_has_bits & 0x00000020u) {
              total_size += 5;
            }
            // float cm_per_360 = 2;
            if (cached_has_bits & 0x00000040u) {
              total_size += 5;
            }
            // float metronome_bpm = 4;
            if (cached_has_bits & 0x00000080u) {
              total_size += 5;
            }
          }
          if (cached_has_bits & 0x00003f00u) {
            // float crosshair_size = 5;
            if (cached_has_bits & 0x00000100u) {
              total_size += 5;
            }
            // bool disable_click_to_start = 8;
            if (cached_has_bits & 0x00000200u) {
              total_size += 2;
            }
            // bool auto_hold_tracking = 10;
            if (cached_has_bits & 0x00000400u) {
              total_size += 2;
            }
            // bool disable_per_scenario_settings = 13;
            if (cached_has_bits & 0x00000800u) {
              total_size += 2;
            }
            // float cm_per_360_jitter = 11;
            if (cached_has_bits & 0x00001000u) {
              total_size += 5;
            }
            // float max_render_fps = 14;
            if (cached_has_bits & 0x00002000u) {
              total_size += 5;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Settings::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Settings*>(&to_msg);
  auto& from = static_cast<const Settings&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.Settings)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_saved_crosshairs()->MergeFrom(
      from._internal_saved_crosshairs());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_theme_name(from._internal_theme_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_current_crosshair_name(from._internal_current_crosshair_name());
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.keybinds_ != nullptr);
      if (_this->_impl_.keybinds_ == nullptr) {
        _this->_impl_.keybinds_ =
            ::google::protobuf::Message::CopyConstruct<::aim::Keybinds>(arena, *from._impl_.keybinds_);
      } else {
        _this->_impl_.keybinds_->MergeFrom(*from._impl_.keybinds_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.health_bar_ != nullptr);
      if (_this->_impl_.health_bar_ == nullptr) {
        _this->_impl_.health_bar_ =
            ::google::protobuf::Message::CopyConstruct<::aim::HealthBarSettings>(arena, *from._impl_.health_bar_);
      } else {
        _this->_impl_.health_bar_->MergeFrom(*from._impl_.health_bar_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(from._impl_.sound_ != nullptr);
      if (_this->_impl_.sound_ == nullptr) {
        _this->_impl_.sound_ =
            ::google::protobuf::Message::CopyConstruct<::aim::SoundSettings>(arena, *from._impl_.sound_);
      } else {
        _this->_impl_.sound_->MergeFrom(*from._impl_.sound_);
      }
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dpi_ = from._impl_.dpi_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.cm_per_360_ = from._impl_.cm_per_360_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.metronome_bpm_ = from._impl_.metronome_bpm_;
    }
  }
  if (cached_has_bits & 0x00003f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.crosshair_size_ = from._impl_.crosshair_size_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.disable_click_to_start_ = from._impl_.disable_click_to_start_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.auto_hold_tracking_ = from._impl_.auto_hold_tracking_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.disable_per_scenario_settings_ = from._impl_.disable_per_scenario_settings_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.cm_per_360_jitter_ = from._impl_.cm_per_360_jitter_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.max_render_fps_ = from._impl_.max_render_fps_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Settings::CopyFrom(const Settings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.Settings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Settings::InternalSwap(Settings* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.saved_crosshairs_.InternalSwap(&other->_impl_.saved_crosshairs_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.theme_name_, &other->_impl_.theme_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.current_crosshair_name_, &other->_impl_.current_crosshair_name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Settings, _impl_.max_render_fps_)
      + sizeof(Settings::_impl_.max_render_fps_)
      - PROTOBUF_FIELD_OFFSET(Settings, _impl_.keybinds_)>(
          reinterpret_cast<char*>(&_impl_.keybinds_),
          reinterpret_cast<char*>(&other->_impl_.keybinds_));
}

::google::protobuf::Metadata Settings::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SoundSettings::_Internal {
 public:
  using HasBits =
      decltype(std::declval<SoundSettings>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_._has_bits_);
};

SoundSettings::SoundSettings(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.SoundSettings)
}
inline PROTOBUF_NDEBUG_INLINE SoundSettings::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::SoundSettings& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        hit_(arena, from.hit_),
        kill_(arena, from.kill_),
        metronome_(arena, from.metronome_),
        shoot_(arena, from.shoot_) {}

SoundSettings::SoundSettings(
    ::google::protobuf::Arena* arena,
    const SoundSettings& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SoundSettings* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:aim.SoundSettings)
}
inline PROTOBUF_NDEBUG_INLINE SoundSettings::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        hit_(arena),
        kill_(arena),
        metronome_(arena),
        shoot_(arena) {}

inline void SoundSettings::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
SoundSettings::~SoundSettings() {
  // @@protoc_insertion_point(destructor:aim.SoundSettings)
  SharedDtor(*this);
}
inline void SoundSettings::SharedDtor(MessageLite& self) {
  SoundSettings& this_ = static_cast<SoundSettings&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.hit_.Destroy();
  this_._impl_.kill_.Destroy();
  this_._impl_.metronome_.Destroy();
  this_._impl_.shoot_.Destroy();
  this_._impl_.~Impl_();
}

inline void* SoundSettings::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) SoundSettings(arena);
}
constexpr auto SoundSettings::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(SoundSettings),
                                            alignof(SoundSettings));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull SoundSettings::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_SoundSettings_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &SoundSettings::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<SoundSettings>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &SoundSettings::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<SoundSettings>(), &SoundSettings::ByteSizeLong,
            &SoundSettings::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_._cached_size_),
        false,
    },
    &SoundSettings::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* SoundSettings::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 47, 2> SoundSettings::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::SoundSettings>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string shoot = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 3, 0, PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_.shoot_)}},
    // string hit = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_.hit_)}},
    // string kill = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_.kill_)}},
    // string metronome = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 2, 0, PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_.metronome_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string hit = 1;
    {PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_.hit_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string kill = 2;
    {PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_.kill_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string metronome = 3;
    {PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_.metronome_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string shoot = 4;
    {PROTOBUF_FIELD_OFFSET(SoundSettings, _impl_.shoot_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\21\3\4\11\5\0\0\0"
    "aim.SoundSettings"
    "hit"
    "kill"
    "metronome"
    "shoot"
  }},
};

PROTOBUF_NOINLINE void SoundSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.SoundSettings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.hit_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.kill_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.metronome_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.shoot_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* SoundSettings::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const SoundSettings& this_ = static_cast<const SoundSettings&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* SoundSettings::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const SoundSettings& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.SoundSettings)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // string hit = 1;
          if (cached_has_bits & 0x00000001u) {
            const std::string& _s = this_._internal_hit();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.SoundSettings.hit");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string kill = 2;
          if (cached_has_bits & 0x00000002u) {
            const std::string& _s = this_._internal_kill();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.SoundSettings.kill");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // string metronome = 3;
          if (cached_has_bits & 0x00000004u) {
            const std::string& _s = this_._internal_metronome();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.SoundSettings.metronome");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          // string shoot = 4;
          if (cached_has_bits & 0x00000008u) {
            const std::string& _s = this_._internal_shoot();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.SoundSettings.shoot");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.SoundSettings)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t SoundSettings::ByteSizeLong(const MessageLite& base) {
          const SoundSettings& this_ = static_cast<const SoundSettings&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t SoundSettings::ByteSizeLong() const {
          const SoundSettings& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.SoundSettings)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000000fu) {
            // string hit = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_hit());
            }
            // string kill = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_kill());
            }
            // string metronome = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_metronome());
            }
            // string shoot = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_shoot());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void SoundSettings::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SoundSettings*>(&to_msg);
  auto& from = static_cast<const SoundSettings&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.SoundSettings)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_hit(from._internal_hit());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_kill(from._internal_kill());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_metronome(from._internal_metronome());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_shoot(from._internal_shoot());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SoundSettings::CopyFrom(const SoundSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.SoundSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SoundSettings::InternalSwap(SoundSettings* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hit_, &other->_impl_.hit_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.kill_, &other->_impl_.kill_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.metronome_, &other->_impl_.metronome_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.shoot_, &other->_impl_.shoot_, arena);
}

::google::protobuf::Metadata SoundSettings::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class ScenarioSettings::_Internal {
 public:
  using HasBits =
      decltype(std::declval<ScenarioSettings>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_._has_bits_);
};

ScenarioSettings::ScenarioSettings(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.ScenarioSettings)
}
inline PROTOBUF_NDEBUG_INLINE ScenarioSettings::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::ScenarioSettings& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        theme_name_(arena, from.theme_name_),
        crosshair_name_(arena, from.crosshair_name_) {}

ScenarioSettings::ScenarioSettings(
    ::google::protobuf::Arena* arena,
    const ScenarioSettings& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  ScenarioSettings* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.health_bar_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::aim::HealthBarSettings>(
                              arena, *from._impl_.health_bar_)
                        : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, cm_per_360_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, cm_per_360_),
           offsetof(Impl_, auto_hold_tracking_) -
               offsetof(Impl_, cm_per_360_) +
               sizeof(Impl_::auto_hold_tracking_));

  // @@protoc_insertion_point(copy_constructor:aim.ScenarioSettings)
}
inline PROTOBUF_NDEBUG_INLINE ScenarioSettings::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        theme_name_(arena),
        crosshair_name_(arena) {}

inline void ScenarioSettings::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, health_bar_),
           0,
           offsetof(Impl_, auto_hold_tracking_) -
               offsetof(Impl_, health_bar_) +
               sizeof(Impl_::auto_hold_tracking_));
}
ScenarioSettings::~ScenarioSettings() {
  // @@protoc_insertion_point(destructor:aim.ScenarioSettings)
  SharedDtor(*this);
}
inline void ScenarioSettings::SharedDtor(MessageLite& self) {
  ScenarioSettings& this_ = static_cast<ScenarioSettings&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.theme_name_.Destroy();
  this_._impl_.crosshair_name_.Destroy();
  delete this_._impl_.health_bar_;
  this_._impl_.~Impl_();
}

inline void* ScenarioSettings::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) ScenarioSettings(arena);
}
constexpr auto ScenarioSettings::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(ScenarioSettings),
                                            alignof(ScenarioSettings));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull ScenarioSettings::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_ScenarioSettings_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &ScenarioSettings::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<ScenarioSettings>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &ScenarioSettings::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<ScenarioSettings>(), &ScenarioSettings::ByteSizeLong,
            &ScenarioSettings::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_._cached_size_),
        false,
    },
    &ScenarioSettings::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* ScenarioSettings::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 8, 1, 61, 2> ScenarioSettings::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_._has_bits_),
    0, // no _extensions_
    8, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967040,  // skipmap
    offsetof(decltype(_table_), field_entries),
    8,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::ScenarioSettings>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // .aim.HealthBarSettings health_bar = 8;
    {::_pbi::TcParser::FastMtS1,
     {66, 2, 0, PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.health_bar_)}},
    // float cm_per_360 = 1;
    {::_pbi::TcParser::FastF32S1,
     {13, 3, 0, PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.cm_per_360_)}},
    // string theme_name = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.theme_name_)}},
    // float metronome_bpm = 3;
    {::_pbi::TcParser::FastF32S1,
     {29, 4, 0, PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.metronome_bpm_)}},
    // float crosshair_size = 4;
    {::_pbi::TcParser::FastF32S1,
     {37, 5, 0, PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.crosshair_size_)}},
    // string crosshair_name = 5;
    {::_pbi::TcParser::FastUS1,
     {42, 1, 0, PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.crosshair_name_)}},
    // float cm_per_360_jitter = 6;
    {::_pbi::TcParser::FastF32S1,
     {53, 6, 0, PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.cm_per_360_jitter_)}},
    // bool auto_hold_tracking = 7;
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(ScenarioSettings, _impl_.auto_hold_tracking_), 7>(),
     {56, 7, 0, PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.auto_hold_tracking_)}},
  }}, {{
    65535, 65535
  }}, {{
    // float cm_per_360 = 1;
    {PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.cm_per_360_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // string theme_name = 2;
    {PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.theme_name_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float metronome_bpm = 3;
    {PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.metronome_bpm_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // float crosshair_size = 4;
    {PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.crosshair_size_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // string crosshair_name = 5;
    {PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.crosshair_name_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float cm_per_360_jitter = 6;
    {PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.cm_per_360_jitter_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
    // bool auto_hold_tracking = 7;
    {PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.auto_hold_tracking_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // .aim.HealthBarSettings health_bar = 8;
    {PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.health_bar_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::aim::HealthBarSettings>()},
  }}, {{
    "\24\0\12\0\0\16\0\0\0\0\0\0\0\0\0\0"
    "aim.ScenarioSettings"
    "theme_name"
    "crosshair_name"
  }},
};

PROTOBUF_NOINLINE void ScenarioSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.ScenarioSettings)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.theme_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.crosshair_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.health_bar_ != nullptr);
      _impl_.health_bar_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.cm_per_360_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.auto_hold_tracking_) -
        reinterpret_cast<char*>(&_impl_.cm_per_360_)) + sizeof(_impl_.auto_hold_tracking_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* ScenarioSettings::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const ScenarioSettings& this_ = static_cast<const ScenarioSettings&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* ScenarioSettings::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const ScenarioSettings& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.ScenarioSettings)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // float cm_per_360 = 1;
          if (cached_has_bits & 0x00000008u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                1, this_._internal_cm_per_360(), target);
          }

          // string theme_name = 2;
          if (cached_has_bits & 0x00000001u) {
            const std::string& _s = this_._internal_theme_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.ScenarioSettings.theme_name");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // float metronome_bpm = 3;
          if (cached_has_bits & 0x00000010u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                3, this_._internal_metronome_bpm(), target);
          }

          // float crosshair_size = 4;
          if (cached_has_bits & 0x00000020u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                4, this_._internal_crosshair_size(), target);
          }

          // string crosshair_name = 5;
          if (cached_has_bits & 0x00000002u) {
            const std::string& _s = this_._internal_crosshair_name();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.ScenarioSettings.crosshair_name");
            target = stream->WriteStringMaybeAliased(5, _s, target);
          }

          // float cm_per_360_jitter = 6;
          if (cached_has_bits & 0x00000040u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteFloatToArray(
                6, this_._internal_cm_per_360_jitter(), target);
          }

          // bool auto_hold_tracking = 7;
          if (cached_has_bits & 0x00000080u) {
            target = stream->EnsureSpace(target);
            target = ::_pbi::WireFormatLite::WriteBoolToArray(
                7, this_._internal_auto_hold_tracking(), target);
          }

          // .aim.HealthBarSettings health_bar = 8;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                8, *this_._impl_.health_bar_, this_._impl_.health_bar_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.ScenarioSettings)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t ScenarioSettings::ByteSizeLong(const MessageLite& base) {
          const ScenarioSettings& this_ = static_cast<const ScenarioSettings&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t ScenarioSettings::ByteSizeLong() const {
          const ScenarioSettings& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.ScenarioSettings)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x000000ffu) {
            // string theme_name = 2;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_theme_name());
            }
            // string crosshair_name = 5;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_crosshair_name());
            }
            // .aim.HealthBarSettings health_bar = 8;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.health_bar_);
            }
            // float cm_per_360 = 1;
            if (cached_has_bits & 0x00000008u) {
              total_size += 5;
            }
            // float metronome_bpm = 3;
            if (cached_has_bits & 0x00000010u) {
              total_size += 5;
            }
            // float crosshair_size = 4;
            if (cached_has_bits & 0x00000020u) {
              total_size += 5;
            }
            // float cm_per_360_jitter = 6;
            if (cached_has_bits & 0x00000040u) {
              total_size += 5;
            }
            // bool auto_hold_tracking = 7;
            if (cached_has_bits & 0x00000080u) {
              total_size += 2;
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void ScenarioSettings::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<ScenarioSettings*>(&to_msg);
  auto& from = static_cast<const ScenarioSettings&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.ScenarioSettings)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_theme_name(from._internal_theme_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_crosshair_name(from._internal_crosshair_name());
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.health_bar_ != nullptr);
      if (_this->_impl_.health_bar_ == nullptr) {
        _this->_impl_.health_bar_ =
            ::google::protobuf::Message::CopyConstruct<::aim::HealthBarSettings>(arena, *from._impl_.health_bar_);
      } else {
        _this->_impl_.health_bar_->MergeFrom(*from._impl_.health_bar_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.cm_per_360_ = from._impl_.cm_per_360_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.metronome_bpm_ = from._impl_.metronome_bpm_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.crosshair_size_ = from._impl_.crosshair_size_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.cm_per_360_jitter_ = from._impl_.cm_per_360_jitter_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.auto_hold_tracking_ = from._impl_.auto_hold_tracking_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void ScenarioSettings::CopyFrom(const ScenarioSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.ScenarioSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void ScenarioSettings::InternalSwap(ScenarioSettings* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.theme_name_, &other->_impl_.theme_name_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.crosshair_name_, &other->_impl_.crosshair_name_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.auto_hold_tracking_)
      + sizeof(ScenarioSettings::_impl_.auto_hold_tracking_)
      - PROTOBUF_FIELD_OFFSET(ScenarioSettings, _impl_.health_bar_)>(
          reinterpret_cast<char*>(&_impl_.health_bar_),
          reinterpret_cast<char*>(&other->_impl_.health_bar_));
}

::google::protobuf::Metadata ScenarioSettings::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class KeyMapping::_Internal {
 public:
  using HasBits =
      decltype(std::declval<KeyMapping>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_._has_bits_);
};

KeyMapping::KeyMapping(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.KeyMapping)
}
inline PROTOBUF_NDEBUG_INLINE KeyMapping::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::KeyMapping& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        mapping1_(arena, from.mapping1_),
        mapping2_(arena, from.mapping2_),
        mapping3_(arena, from.mapping3_),
        mapping4_(arena, from.mapping4_) {}

KeyMapping::KeyMapping(
    ::google::protobuf::Arena* arena,
    const KeyMapping& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  KeyMapping* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);

  // @@protoc_insertion_point(copy_constructor:aim.KeyMapping)
}
inline PROTOBUF_NDEBUG_INLINE KeyMapping::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0},
        mapping1_(arena),
        mapping2_(arena),
        mapping3_(arena),
        mapping4_(arena) {}

inline void KeyMapping::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
}
KeyMapping::~KeyMapping() {
  // @@protoc_insertion_point(destructor:aim.KeyMapping)
  SharedDtor(*this);
}
inline void KeyMapping::SharedDtor(MessageLite& self) {
  KeyMapping& this_ = static_cast<KeyMapping&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.mapping1_.Destroy();
  this_._impl_.mapping2_.Destroy();
  this_._impl_.mapping3_.Destroy();
  this_._impl_.mapping4_.Destroy();
  this_._impl_.~Impl_();
}

inline void* KeyMapping::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) KeyMapping(arena);
}
constexpr auto KeyMapping::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(KeyMapping),
                                            alignof(KeyMapping));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull KeyMapping::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_KeyMapping_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &KeyMapping::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<KeyMapping>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &KeyMapping::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<KeyMapping>(), &KeyMapping::ByteSizeLong,
            &KeyMapping::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_._cached_size_),
        false,
    },
    &KeyMapping::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* KeyMapping::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 55, 2> KeyMapping::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::KeyMapping>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string mapping4 = 4;
    {::_pbi::TcParser::FastUS1,
     {34, 3, 0, PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_.mapping4_)}},
    // string mapping1 = 1;
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_.mapping1_)}},
    // string mapping2 = 2;
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_.mapping2_)}},
    // string mapping3 = 3;
    {::_pbi::TcParser::FastUS1,
     {26, 2, 0, PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_.mapping3_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string mapping1 = 1;
    {PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_.mapping1_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string mapping2 = 2;
    {PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_.mapping2_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string mapping3 = 3;
    {PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_.mapping3_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string mapping4 = 4;
    {PROTOBUF_FIELD_OFFSET(KeyMapping, _impl_.mapping4_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\16\10\10\10\10\0\0\0"
    "aim.KeyMapping"
    "mapping1"
    "mapping2"
    "mapping3"
    "mapping4"
  }},
};

PROTOBUF_NOINLINE void KeyMapping::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.KeyMapping)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.mapping1_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.mapping2_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.mapping3_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.mapping4_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* KeyMapping::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const KeyMapping& this_ = static_cast<const KeyMapping&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* KeyMapping::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const KeyMapping& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.KeyMapping)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // string mapping1 = 1;
          if (cached_has_bits & 0x00000001u) {
            const std::string& _s = this_._internal_mapping1();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.KeyMapping.mapping1");
            target = stream->WriteStringMaybeAliased(1, _s, target);
          }

          // string mapping2 = 2;
          if (cached_has_bits & 0x00000002u) {
            const std::string& _s = this_._internal_mapping2();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.KeyMapping.mapping2");
            target = stream->WriteStringMaybeAliased(2, _s, target);
          }

          // string mapping3 = 3;
          if (cached_has_bits & 0x00000004u) {
            const std::string& _s = this_._internal_mapping3();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.KeyMapping.mapping3");
            target = stream->WriteStringMaybeAliased(3, _s, target);
          }

          // string mapping4 = 4;
          if (cached_has_bits & 0x00000008u) {
            const std::string& _s = this_._internal_mapping4();
            ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
                _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "aim.KeyMapping.mapping4");
            target = stream->WriteStringMaybeAliased(4, _s, target);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.KeyMapping)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t KeyMapping::ByteSizeLong(const MessageLite& base) {
          const KeyMapping& this_ = static_cast<const KeyMapping&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t KeyMapping::ByteSizeLong() const {
          const KeyMapping& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.KeyMapping)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000000fu) {
            // string mapping1 = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_mapping1());
            }
            // string mapping2 = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_mapping2());
            }
            // string mapping3 = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_mapping3());
            }
            // string mapping4 = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                              this_._internal_mapping4());
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void KeyMapping::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<KeyMapping*>(&to_msg);
  auto& from = static_cast<const KeyMapping&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.KeyMapping)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_mapping1(from._internal_mapping1());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_mapping2(from._internal_mapping2());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_mapping3(from._internal_mapping3());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_mapping4(from._internal_mapping4());
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void KeyMapping::CopyFrom(const KeyMapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.KeyMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void KeyMapping::InternalSwap(KeyMapping* PROTOBUF_RESTRICT other) {
  using std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mapping1_, &other->_impl_.mapping1_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mapping2_, &other->_impl_.mapping2_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mapping3_, &other->_impl_.mapping3_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.mapping4_, &other->_impl_.mapping4_, arena);
}

::google::protobuf::Metadata KeyMapping::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class Keybinds::_Internal {
 public:
  using HasBits =
      decltype(std::declval<Keybinds>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(Keybinds, _impl_._has_bits_);
};

Keybinds::Keybinds(::google::protobuf::Arena* arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:aim.Keybinds)
}
inline PROTOBUF_NDEBUG_INLINE Keybinds::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility, ::google::protobuf::Arena* arena,
    const Impl_& from, const ::aim::Keybinds& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0} {}

Keybinds::Keybinds(
    ::google::protobuf::Arena* arena,
    const Keybinds& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, _class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  Keybinds* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.fire_ = (cached_has_bits & 0x00000001u) ? ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(
                              arena, *from._impl_.fire_)
                        : nullptr;
  _impl_.restart_scenario_ = (cached_has_bits & 0x00000002u) ? ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(
                              arena, *from._impl_.restart_scenario_)
                        : nullptr;
  _impl_.next_scenario_ = (cached_has_bits & 0x00000004u) ? ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(
                              arena, *from._impl_.next_scenario_)
                        : nullptr;
  _impl_.quick_settings_ = (cached_has_bits & 0x00000008u) ? ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(
                              arena, *from._impl_.quick_settings_)
                        : nullptr;
  _impl_.adjust_crosshair_size_ = (cached_has_bits & 0x00000010u) ? ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(
                              arena, *from._impl_.adjust_crosshair_size_)
                        : nullptr;
  _impl_.quick_metronome_ = (cached_has_bits & 0x00000020u) ? ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(
                              arena, *from._impl_.quick_metronome_)
                        : nullptr;
  _impl_.edit_scenario_ = (cached_has_bits & 0x00000040u) ? ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(
                              arena, *from._impl_.edit_scenario_)
                        : nullptr;

  // @@protoc_insertion_point(copy_constructor:aim.Keybinds)
}
inline PROTOBUF_NDEBUG_INLINE Keybinds::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* arena)
      : _cached_size_{0} {}

inline void Keybinds::SharedCtor(::_pb::Arena* arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, fire_),
           0,
           offsetof(Impl_, edit_scenario_) -
               offsetof(Impl_, fire_) +
               sizeof(Impl_::edit_scenario_));
}
Keybinds::~Keybinds() {
  // @@protoc_insertion_point(destructor:aim.Keybinds)
  SharedDtor(*this);
}
inline void Keybinds::SharedDtor(MessageLite& self) {
  Keybinds& this_ = static_cast<Keybinds&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  delete this_._impl_.fire_;
  delete this_._impl_.restart_scenario_;
  delete this_._impl_.next_scenario_;
  delete this_._impl_.quick_settings_;
  delete this_._impl_.adjust_crosshair_size_;
  delete this_._impl_.quick_metronome_;
  delete this_._impl_.edit_scenario_;
  this_._impl_.~Impl_();
}

inline void* Keybinds::PlacementNew_(const void*, void* mem,
                                        ::google::protobuf::Arena* arena) {
  return ::new (mem) Keybinds(arena);
}
constexpr auto Keybinds::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::ZeroInit(sizeof(Keybinds),
                                            alignof(Keybinds));
}
PROTOBUF_CONSTINIT
PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::google::protobuf::internal::ClassDataFull Keybinds::_class_data_ = {
    ::google::protobuf::internal::ClassData{
        &_Keybinds_default_instance_._instance,
        &_table_.header,
        nullptr,  // OnDemandRegisterArenaDtor
        nullptr,  // IsInitialized
        &Keybinds::MergeImpl,
        ::google::protobuf::Message::GetNewImpl<Keybinds>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
        &Keybinds::SharedDtor,
        ::google::protobuf::Message::GetClearImpl<Keybinds>(), &Keybinds::ByteSizeLong,
            &Keybinds::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
        PROTOBUF_FIELD_OFFSET(Keybinds, _impl_._cached_size_),
        false,
    },
    &Keybinds::kDescriptorMethods,
    &descriptor_table_settings_2eproto,
    nullptr,  // tracker
};
const ::google::protobuf::internal::ClassData* Keybinds::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(_class_data_.tc_table);
  return _class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 7, 7, 0, 2> Keybinds::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(Keybinds, _impl_._has_bits_),
    0, // no _extensions_
    7, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967168,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    7,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    _class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::aim::Keybinds>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .aim.KeyMapping fire = 1;
    {::_pbi::TcParser::FastMtS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.fire_)}},
    // .aim.KeyMapping restart_scenario = 2;
    {::_pbi::TcParser::FastMtS1,
     {18, 1, 1, PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.restart_scenario_)}},
    // .aim.KeyMapping next_scenario = 3;
    {::_pbi::TcParser::FastMtS1,
     {26, 2, 2, PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.next_scenario_)}},
    // .aim.KeyMapping quick_settings = 4;
    {::_pbi::TcParser::FastMtS1,
     {34, 3, 3, PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.quick_settings_)}},
    // .aim.KeyMapping adjust_crosshair_size = 5;
    {::_pbi::TcParser::FastMtS1,
     {42, 4, 4, PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.adjust_crosshair_size_)}},
    // .aim.KeyMapping quick_metronome = 6;
    {::_pbi::TcParser::FastMtS1,
     {50, 5, 5, PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.quick_metronome_)}},
    // .aim.KeyMapping edit_scenario = 7;
    {::_pbi::TcParser::FastMtS1,
     {58, 6, 6, PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.edit_scenario_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .aim.KeyMapping fire = 1;
    {PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.fire_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.KeyMapping restart_scenario = 2;
    {PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.restart_scenario_), _Internal::kHasBitsOffset + 1, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.KeyMapping next_scenario = 3;
    {PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.next_scenario_), _Internal::kHasBitsOffset + 2, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.KeyMapping quick_settings = 4;
    {PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.quick_settings_), _Internal::kHasBitsOffset + 3, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.KeyMapping adjust_crosshair_size = 5;
    {PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.adjust_crosshair_size_), _Internal::kHasBitsOffset + 4, 4,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.KeyMapping quick_metronome = 6;
    {PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.quick_metronome_), _Internal::kHasBitsOffset + 5, 5,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .aim.KeyMapping edit_scenario = 7;
    {PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.edit_scenario_), _Internal::kHasBitsOffset + 6, 6,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }}, {{
    {::_pbi::TcParser::GetTable<::aim::KeyMapping>()},
    {::_pbi::TcParser::GetTable<::aim::KeyMapping>()},
    {::_pbi::TcParser::GetTable<::aim::KeyMapping>()},
    {::_pbi::TcParser::GetTable<::aim::KeyMapping>()},
    {::_pbi::TcParser::GetTable<::aim::KeyMapping>()},
    {::_pbi::TcParser::GetTable<::aim::KeyMapping>()},
    {::_pbi::TcParser::GetTable<::aim::KeyMapping>()},
  }}, {{
  }},
};

PROTOBUF_NOINLINE void Keybinds::Clear() {
// @@protoc_insertion_point(message_clear_start:aim.Keybinds)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.fire_ != nullptr);
      _impl_.fire_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.restart_scenario_ != nullptr);
      _impl_.restart_scenario_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(_impl_.next_scenario_ != nullptr);
      _impl_.next_scenario_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(_impl_.quick_settings_ != nullptr);
      _impl_.quick_settings_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(_impl_.adjust_crosshair_size_ != nullptr);
      _impl_.adjust_crosshair_size_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(_impl_.quick_metronome_ != nullptr);
      _impl_.quick_metronome_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(_impl_.edit_scenario_ != nullptr);
      _impl_.edit_scenario_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::uint8_t* Keybinds::_InternalSerialize(
            const MessageLite& base, ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) {
          const Keybinds& this_ = static_cast<const Keybinds&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::uint8_t* Keybinds::_InternalSerialize(
            ::uint8_t* target,
            ::google::protobuf::io::EpsCopyOutputStream* stream) const {
          const Keybinds& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(serialize_to_array_start:aim.Keybinds)
          ::uint32_t cached_has_bits = 0;
          (void)cached_has_bits;

          cached_has_bits = this_._impl_._has_bits_[0];
          // .aim.KeyMapping fire = 1;
          if (cached_has_bits & 0x00000001u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                1, *this_._impl_.fire_, this_._impl_.fire_->GetCachedSize(), target,
                stream);
          }

          // .aim.KeyMapping restart_scenario = 2;
          if (cached_has_bits & 0x00000002u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                2, *this_._impl_.restart_scenario_, this_._impl_.restart_scenario_->GetCachedSize(), target,
                stream);
          }

          // .aim.KeyMapping next_scenario = 3;
          if (cached_has_bits & 0x00000004u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                3, *this_._impl_.next_scenario_, this_._impl_.next_scenario_->GetCachedSize(), target,
                stream);
          }

          // .aim.KeyMapping quick_settings = 4;
          if (cached_has_bits & 0x00000008u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                4, *this_._impl_.quick_settings_, this_._impl_.quick_settings_->GetCachedSize(), target,
                stream);
          }

          // .aim.KeyMapping adjust_crosshair_size = 5;
          if (cached_has_bits & 0x00000010u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                5, *this_._impl_.adjust_crosshair_size_, this_._impl_.adjust_crosshair_size_->GetCachedSize(), target,
                stream);
          }

          // .aim.KeyMapping quick_metronome = 6;
          if (cached_has_bits & 0x00000020u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                6, *this_._impl_.quick_metronome_, this_._impl_.quick_metronome_->GetCachedSize(), target,
                stream);
          }

          // .aim.KeyMapping edit_scenario = 7;
          if (cached_has_bits & 0x00000040u) {
            target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
                7, *this_._impl_.edit_scenario_, this_._impl_.edit_scenario_->GetCachedSize(), target,
                stream);
          }

          if (PROTOBUF_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
            target =
                ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
                    this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
          }
          // @@protoc_insertion_point(serialize_to_array_end:aim.Keybinds)
          return target;
        }

#if defined(PROTOBUF_CUSTOM_VTABLE)
        ::size_t Keybinds::ByteSizeLong(const MessageLite& base) {
          const Keybinds& this_ = static_cast<const Keybinds&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
        ::size_t Keybinds::ByteSizeLong() const {
          const Keybinds& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
          // @@protoc_insertion_point(message_byte_size_start:aim.Keybinds)
          ::size_t total_size = 0;

          ::uint32_t cached_has_bits = 0;
          // Prevent compiler warnings about cached_has_bits being unused
          (void)cached_has_bits;

          ::_pbi::Prefetch5LinesFrom7Lines(&this_);
          cached_has_bits = this_._impl_._has_bits_[0];
          if (cached_has_bits & 0x0000007fu) {
            // .aim.KeyMapping fire = 1;
            if (cached_has_bits & 0x00000001u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.fire_);
            }
            // .aim.KeyMapping restart_scenario = 2;
            if (cached_has_bits & 0x00000002u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.restart_scenario_);
            }
            // .aim.KeyMapping next_scenario = 3;
            if (cached_has_bits & 0x00000004u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.next_scenario_);
            }
            // .aim.KeyMapping quick_settings = 4;
            if (cached_has_bits & 0x00000008u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.quick_settings_);
            }
            // .aim.KeyMapping adjust_crosshair_size = 5;
            if (cached_has_bits & 0x00000010u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.adjust_crosshair_size_);
            }
            // .aim.KeyMapping quick_metronome = 6;
            if (cached_has_bits & 0x00000020u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.quick_metronome_);
            }
            // .aim.KeyMapping edit_scenario = 7;
            if (cached_has_bits & 0x00000040u) {
              total_size += 1 +
                            ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.edit_scenario_);
            }
          }
          return this_.MaybeComputeUnknownFieldsSize(total_size,
                                                     &this_._impl_._cached_size_);
        }

void Keybinds::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<Keybinds*>(&to_msg);
  auto& from = static_cast<const Keybinds&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:aim.Keybinds)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(from._impl_.fire_ != nullptr);
      if (_this->_impl_.fire_ == nullptr) {
        _this->_impl_.fire_ =
            ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(arena, *from._impl_.fire_);
      } else {
        _this->_impl_.fire_->MergeFrom(*from._impl_.fire_);
      }
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(from._impl_.restart_scenario_ != nullptr);
      if (_this->_impl_.restart_scenario_ == nullptr) {
        _this->_impl_.restart_scenario_ =
            ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(arena, *from._impl_.restart_scenario_);
      } else {
        _this->_impl_.restart_scenario_->MergeFrom(*from._impl_.restart_scenario_);
      }
    }
    if (cached_has_bits & 0x00000004u) {
      ABSL_DCHECK(from._impl_.next_scenario_ != nullptr);
      if (_this->_impl_.next_scenario_ == nullptr) {
        _this->_impl_.next_scenario_ =
            ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(arena, *from._impl_.next_scenario_);
      } else {
        _this->_impl_.next_scenario_->MergeFrom(*from._impl_.next_scenario_);
      }
    }
    if (cached_has_bits & 0x00000008u) {
      ABSL_DCHECK(from._impl_.quick_settings_ != nullptr);
      if (_this->_impl_.quick_settings_ == nullptr) {
        _this->_impl_.quick_settings_ =
            ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(arena, *from._impl_.quick_settings_);
      } else {
        _this->_impl_.quick_settings_->MergeFrom(*from._impl_.quick_settings_);
      }
    }
    if (cached_has_bits & 0x00000010u) {
      ABSL_DCHECK(from._impl_.adjust_crosshair_size_ != nullptr);
      if (_this->_impl_.adjust_crosshair_size_ == nullptr) {
        _this->_impl_.adjust_crosshair_size_ =
            ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(arena, *from._impl_.adjust_crosshair_size_);
      } else {
        _this->_impl_.adjust_crosshair_size_->MergeFrom(*from._impl_.adjust_crosshair_size_);
      }
    }
    if (cached_has_bits & 0x00000020u) {
      ABSL_DCHECK(from._impl_.quick_metronome_ != nullptr);
      if (_this->_impl_.quick_metronome_ == nullptr) {
        _this->_impl_.quick_metronome_ =
            ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(arena, *from._impl_.quick_metronome_);
      } else {
        _this->_impl_.quick_metronome_->MergeFrom(*from._impl_.quick_metronome_);
      }
    }
    if (cached_has_bits & 0x00000040u) {
      ABSL_DCHECK(from._impl_.edit_scenario_ != nullptr);
      if (_this->_impl_.edit_scenario_ == nullptr) {
        _this->_impl_.edit_scenario_ =
            ::google::protobuf::Message::CopyConstruct<::aim::KeyMapping>(arena, *from._impl_.edit_scenario_);
      } else {
        _this->_impl_.edit_scenario_->MergeFrom(*from._impl_.edit_scenario_);
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void Keybinds::CopyFrom(const Keybinds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:aim.Keybinds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void Keybinds::InternalSwap(Keybinds* PROTOBUF_RESTRICT other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.edit_scenario_)
      + sizeof(Keybinds::_impl_.edit_scenario_)
      - PROTOBUF_FIELD_OFFSET(Keybinds, _impl_.fire_)>(
          reinterpret_cast<char*>(&_impl_.fire_),
          reinterpret_cast<char*>(&other->_impl_.fire_));
}

::google::protobuf::Metadata Keybinds::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace aim
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ PROTOBUF_UNUSED =
        (::_pbi::AddDescriptors(&descriptor_table_settings_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
