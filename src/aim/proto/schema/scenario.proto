edition = "2023";

import "common.proto";

package aim;

// Room defined by dimensions of the back wall the user is facing.
message SimpleRoom {
  float height = 1;
  float width = 2;
  float depth = 3;
}

message CircularRoom {
  float height = 1;
  float radius = 2;
  // The width of the wall to use for target placement and to draw sides.
  float width = 3;
  bool hide_sides = 4;
  // Defaults to 20.
  float side_angle_degrees = 5;
}

// Similar to a circular room but you are looking at the flat side and the side walls are
// cylindrical.
message BarrelRoom {
  float radius = 1;
}

message Room {
  StoredVec3 camera_position = 1;
  float start_pitch = 2;
  float start_yaw = 3;
  oneof type {
    SimpleRoom simple_room = 4;
    CircularRoom circular_room = 5;
    BarrelRoom barrel_room = 6;
  }
}

// For circular rooms x is effectively in degrees.
message RegionLength {
  oneof type {
    // Length is a percent of relevant dimension (x,y) on the wall.
    float x_percent_value = 1;
    float y_percent_value = 2;
    float value = 3;
  }
}

message TargetRegion {
  // The percent chance the target will be placed in this region. 0-1
  // First matching region will be chosen. Defaults to 1.
  float percent_chance = 1;

  // (0, 0) is the center of the wall.
  RegionLength x_offset = 2;
  RegionLength y_offset = 3;

  oneof type {
    RectangleTargetRegion rectangle = 4;
    EllipseTargetRegion ellipse = 5;
    CircleTargetRegion circle = 6;
  }
}

message RectangleTargetRegion {
  RegionLength x_length = 1;
  RegionLength y_length = 2;

  // If specified the inner rectangle will be cut out. If only 1 of x or y is specified then the other dimension will be assumed the full length resulting in two rectangular regions.
  RegionLength inner_x_length = 3;
  RegionLength inner_y_length = 4;
}

message EllipseTargetRegion {
  RegionLength x_diameter = 1;
  RegionLength y_diameter = 2;
}

message CircleTargetRegion {
  RegionLength diameter = 1;
  // Optional. If specified the region will be a donut.
  RegionLength inner_diameter = 2;
}

message TargetPlacementStrategy {
  repeated TargetRegion regions = 1;
  // If non empty, target regions will be chosen in the specified pattern repeating. 0 indexed.
  repeated int32 region_order = 2;

  float min_distance = 3;

  // The next target will be placed at the specified distance from the last target within the
  // specified region. A random direction will be chosen.
  float fixed_distance_from_last_target = 4;
  // If using fixed distance allow the distance to vary by this amount. i.e. +/- jitter.
  float fixed_distance_jitter = 5;
}

message ScenarioReferenceOverrides {
  float duration_seconds = 1;
  float target_radius_multiplier = 2;
  int32 num_targets = 3;
  float speed_multiplier = 4;
}

message ShotType {
  oneof type {
    // Targets are killed after being "tracked"" consistently for a short duration. Typical for
    // static scenarios. Mouse does not need to be held done or clicked.
    bool poke = 1;
    // Targets have health and must be traced for a certain amount of time.
    bool tracking_kill = 2;
    // A single target will be tracked and the total time on target will be the score.
    bool tracking_invincible = 3;
    // Target take a single click to kill.
    bool click_single = 4;
  }
  // If unset defaults to 0.05 (50 millis)
  float poke_kill_time_seconds = 10;

  // Partial kills are not counted towards score.
  bool no_partial_kills = 11;
}

message ScenarioDef {
  string scenario_id = 1;
  float duration_seconds = 2;
  Room room = 3;
  TargetDef target_def = 5;

  // This scenario is a reference to another scenario with the id changed.
  string reference = 6;
  ScenarioReferenceOverrides overrides = 7;

  ShotType shot_type = 8;

  oneof type {
    StaticScenarioDef static_def = 10;
    CenteringScenarioDef centering_def = 11;
    BarrelScenarioDef barrel_def = 12;
    LinearScenarioDef linear_def = 13;
  }
}

message StaticScenarioDef {
  TargetPlacementStrategy target_placement_strategy = 1;
}

message CenteringScenarioDef {
  StoredVec3 start_position = 1;
  StoredVec3 end_position = 2;
}

message BarrelScenarioDef {
    // Typically a Cirle region with the middle missing.
  TargetPlacementStrategy target_placement_strategy = 1;
  // When targets spawn or hit a wall they will be directed towards a point in the center percent of the barrel.
  float direction_radius_percent = 2;
}

// Targets move linearly within the specified room. Uses 2d wall placement so it support simple room
// types.
message LinearScenarioDef {
  // O degrees would move horizontally. 90 degrees would move vetically. Values must be between
  // 0-90.
  float angle = 1;
  float angle_jitter = 2;
  // Override width or height of the room. Cannot exceed the room width or height.
  float width = 3;
  float height = 4;

  TargetPlacementStrategy target_placement_strategy = 5;
}

message TargetDef {
  repeated TargetProfile profiles = 1;
  int32 num_targets = 2;
  // For clicking scenarios, remove the target if you miss it.
  bool remove_closest_on_miss = 3;

  // If non empty, target profiles will be chosen in the specified pattern repeating. 0 indexed.
  repeated int32 target_order = 4;

  // The most recently placed target will not be clickable and will be
  // displayed with a separate color as determined by theme. This is
  // useful for forced pathing so you know where the target will be
  // but have to click in the correct order.
  bool newest_target_is_ghost = 5;

  // New targets will be added after the specified amount of seconds.
  float new_target_delay_seconds = 6;

  // A target will automatically be removed after the specified amount of seconds.
  float remove_target_after_seconds = 7;

  // The initial target will be added with the specified delay between each target.
  float stagger_initial_targets_seconds = 8;
}

message PillTargetDef {
  float height = 1;
}

message TargetProfile {
  float percent_chance = 1;

  float target_radius = 2;
  float target_radius_jitter = 3;

  float speed = 4;
  // Speed will be adjusted +/- jitter amount.
  float speed_jitter = 5;

  float health_seconds = 6;
  float health_seconds_jitter = 7;

  // Defaults to spehere if no more specific type is specified.
  oneof type {
    PillTargetDef pill = 10;
  }
}
