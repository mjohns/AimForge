// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENARIODEF_AIM_H_
#define FLATBUFFERS_GENERATED_SCENARIODEF_AIM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

namespace aim {

struct RoomDef;
struct RoomDefBuilder;
struct RoomDefT;

struct SimpleStaticScenarioDef;
struct SimpleStaticScenarioDefBuilder;
struct SimpleStaticScenarioDefT;

struct ScenarioDef;
struct ScenarioDefBuilder;
struct ScenarioDefT;

enum ScenarioDefType : uint8_t {
  ScenarioDefType_NONE = 0,
  ScenarioDefType_simple_static = 1,
  ScenarioDefType_MIN = ScenarioDefType_NONE,
  ScenarioDefType_MAX = ScenarioDefType_simple_static
};

inline const ScenarioDefType (&EnumValuesScenarioDefType())[2] {
  static const ScenarioDefType values[] = {
    ScenarioDefType_NONE,
    ScenarioDefType_simple_static
  };
  return values;
}

inline const char * const *EnumNamesScenarioDefType() {
  static const char * const names[3] = {
    "NONE",
    "simple_static",
    nullptr
  };
  return names;
}

inline const char *EnumNameScenarioDefType(ScenarioDefType e) {
  if (::flatbuffers::IsOutRange(e, ScenarioDefType_NONE, ScenarioDefType_simple_static)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScenarioDefType()[index];
}

template<typename T> struct ScenarioDefTypeTraits {
  static const ScenarioDefType enum_value = ScenarioDefType_NONE;
};

template<> struct ScenarioDefTypeTraits<aim::SimpleStaticScenarioDef> {
  static const ScenarioDefType enum_value = ScenarioDefType_simple_static;
};

template<typename T> struct ScenarioDefTypeUnionTraits {
  static const ScenarioDefType enum_value = ScenarioDefType_NONE;
};

template<> struct ScenarioDefTypeUnionTraits<aim::SimpleStaticScenarioDefT> {
  static const ScenarioDefType enum_value = ScenarioDefType_simple_static;
};

struct ScenarioDefTypeUnion {
  ScenarioDefType type;
  void *value;

  ScenarioDefTypeUnion() : type(ScenarioDefType_NONE), value(nullptr) {}
  ScenarioDefTypeUnion(ScenarioDefTypeUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ScenarioDefType_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ScenarioDefTypeUnion(const ScenarioDefTypeUnion &);
  ScenarioDefTypeUnion &operator=(const ScenarioDefTypeUnion &u)
    { ScenarioDefTypeUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ScenarioDefTypeUnion &operator=(ScenarioDefTypeUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ScenarioDefTypeUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ScenarioDefTypeUnionTraits<RT>::enum_value;
    if (type != ScenarioDefType_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ScenarioDefType type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  aim::SimpleStaticScenarioDefT *Assimple_static() {
    return type == ScenarioDefType_simple_static ?
      reinterpret_cast<aim::SimpleStaticScenarioDefT *>(value) : nullptr;
  }
  const aim::SimpleStaticScenarioDefT *Assimple_static() const {
    return type == ScenarioDefType_simple_static ?
      reinterpret_cast<const aim::SimpleStaticScenarioDefT *>(value) : nullptr;
  }
};

bool VerifyScenarioDefType(::flatbuffers::Verifier &verifier, const void *obj, ScenarioDefType type);
bool VerifyScenarioDefTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct RoomDefT : public ::flatbuffers::NativeTable {
  typedef RoomDef TableType;
  float width = 0.0f;
  float height = 0.0f;
  float camera_height_percent = 0.0f;
  float camera_distance = 0.0f;
};

struct RoomDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoomDefT NativeTableType;
  typedef RoomDefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTH = 4,
    VT_HEIGHT = 6,
    VT_CAMERA_HEIGHT_PERCENT = 8,
    VT_CAMERA_DISTANCE = 10
  };
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float height() const {
    return GetField<float>(VT_HEIGHT, 0.0f);
  }
  float camera_height_percent() const {
    return GetField<float>(VT_CAMERA_HEIGHT_PERCENT, 0.0f);
  }
  float camera_distance() const {
    return GetField<float>(VT_CAMERA_DISTANCE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_HEIGHT, 4) &&
           VerifyField<float>(verifier, VT_CAMERA_HEIGHT_PERCENT, 4) &&
           VerifyField<float>(verifier, VT_CAMERA_DISTANCE, 4) &&
           verifier.EndTable();
  }
  RoomDefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoomDefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RoomDef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RoomDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoomDefBuilder {
  typedef RoomDef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_width(float width) {
    fbb_.AddElement<float>(RoomDef::VT_WIDTH, width, 0.0f);
  }
  void add_height(float height) {
    fbb_.AddElement<float>(RoomDef::VT_HEIGHT, height, 0.0f);
  }
  void add_camera_height_percent(float camera_height_percent) {
    fbb_.AddElement<float>(RoomDef::VT_CAMERA_HEIGHT_PERCENT, camera_height_percent, 0.0f);
  }
  void add_camera_distance(float camera_distance) {
    fbb_.AddElement<float>(RoomDef::VT_CAMERA_DISTANCE, camera_distance, 0.0f);
  }
  explicit RoomDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoomDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoomDef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoomDef> CreateRoomDef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float width = 0.0f,
    float height = 0.0f,
    float camera_height_percent = 0.0f,
    float camera_distance = 0.0f) {
  RoomDefBuilder builder_(_fbb);
  builder_.add_camera_distance(camera_distance);
  builder_.add_camera_height_percent(camera_height_percent);
  builder_.add_height(height);
  builder_.add_width(width);
  return builder_.Finish();
}

::flatbuffers::Offset<RoomDef> CreateRoomDef(::flatbuffers::FlatBufferBuilder &_fbb, const RoomDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SimpleStaticScenarioDefT : public ::flatbuffers::NativeTable {
  typedef SimpleStaticScenarioDef TableType;
  std::unique_ptr<aim::RoomDefT> room{};
  uint16_t num_targets = 0;
  float target_radius = 0.0f;
  SimpleStaticScenarioDefT() = default;
  SimpleStaticScenarioDefT(const SimpleStaticScenarioDefT &o);
  SimpleStaticScenarioDefT(SimpleStaticScenarioDefT&&) FLATBUFFERS_NOEXCEPT = default;
  SimpleStaticScenarioDefT &operator=(SimpleStaticScenarioDefT o) FLATBUFFERS_NOEXCEPT;
};

struct SimpleStaticScenarioDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SimpleStaticScenarioDefT NativeTableType;
  typedef SimpleStaticScenarioDefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOM = 4,
    VT_NUM_TARGETS = 6,
    VT_TARGET_RADIUS = 8
  };
  const aim::RoomDef *room() const {
    return GetPointer<const aim::RoomDef *>(VT_ROOM);
  }
  uint16_t num_targets() const {
    return GetField<uint16_t>(VT_NUM_TARGETS, 0);
  }
  float target_radius() const {
    return GetField<float>(VT_TARGET_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOM) &&
           verifier.VerifyTable(room()) &&
           VerifyField<uint16_t>(verifier, VT_NUM_TARGETS, 2) &&
           VerifyField<float>(verifier, VT_TARGET_RADIUS, 4) &&
           verifier.EndTable();
  }
  SimpleStaticScenarioDefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SimpleStaticScenarioDefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SimpleStaticScenarioDef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SimpleStaticScenarioDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SimpleStaticScenarioDefBuilder {
  typedef SimpleStaticScenarioDef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_room(::flatbuffers::Offset<aim::RoomDef> room) {
    fbb_.AddOffset(SimpleStaticScenarioDef::VT_ROOM, room);
  }
  void add_num_targets(uint16_t num_targets) {
    fbb_.AddElement<uint16_t>(SimpleStaticScenarioDef::VT_NUM_TARGETS, num_targets, 0);
  }
  void add_target_radius(float target_radius) {
    fbb_.AddElement<float>(SimpleStaticScenarioDef::VT_TARGET_RADIUS, target_radius, 0.0f);
  }
  explicit SimpleStaticScenarioDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SimpleStaticScenarioDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SimpleStaticScenarioDef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SimpleStaticScenarioDef> CreateSimpleStaticScenarioDef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<aim::RoomDef> room = 0,
    uint16_t num_targets = 0,
    float target_radius = 0.0f) {
  SimpleStaticScenarioDefBuilder builder_(_fbb);
  builder_.add_target_radius(target_radius);
  builder_.add_room(room);
  builder_.add_num_targets(num_targets);
  return builder_.Finish();
}

::flatbuffers::Offset<SimpleStaticScenarioDef> CreateSimpleStaticScenarioDef(::flatbuffers::FlatBufferBuilder &_fbb, const SimpleStaticScenarioDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScenarioDefT : public ::flatbuffers::NativeTable {
  typedef ScenarioDef TableType;
  std::string display_name{};
  std::string id{};
  aim::ScenarioDefTypeUnion scenario_type{};
};

struct ScenarioDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScenarioDefT NativeTableType;
  typedef ScenarioDefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DISPLAY_NAME = 4,
    VT_ID = 6,
    VT_SCENARIO_TYPE_TYPE = 8,
    VT_SCENARIO_TYPE = 10
  };
  const ::flatbuffers::String *display_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DISPLAY_NAME);
  }
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  aim::ScenarioDefType scenario_type_type() const {
    return static_cast<aim::ScenarioDefType>(GetField<uint8_t>(VT_SCENARIO_TYPE_TYPE, 0));
  }
  const void *scenario_type() const {
    return GetPointer<const void *>(VT_SCENARIO_TYPE);
  }
  template<typename T> const T *scenario_type_as() const;
  const aim::SimpleStaticScenarioDef *scenario_type_as_simple_static() const {
    return scenario_type_type() == aim::ScenarioDefType_simple_static ? static_cast<const aim::SimpleStaticScenarioDef *>(scenario_type()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DISPLAY_NAME) &&
           verifier.VerifyString(display_name()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint8_t>(verifier, VT_SCENARIO_TYPE_TYPE, 1) &&
           VerifyOffset(verifier, VT_SCENARIO_TYPE) &&
           VerifyScenarioDefType(verifier, scenario_type(), scenario_type_type()) &&
           verifier.EndTable();
  }
  ScenarioDefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScenarioDefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ScenarioDef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ScenarioDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const aim::SimpleStaticScenarioDef *ScenarioDef::scenario_type_as<aim::SimpleStaticScenarioDef>() const {
  return scenario_type_as_simple_static();
}

struct ScenarioDefBuilder {
  typedef ScenarioDef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_display_name(::flatbuffers::Offset<::flatbuffers::String> display_name) {
    fbb_.AddOffset(ScenarioDef::VT_DISPLAY_NAME, display_name);
  }
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ScenarioDef::VT_ID, id);
  }
  void add_scenario_type_type(aim::ScenarioDefType scenario_type_type) {
    fbb_.AddElement<uint8_t>(ScenarioDef::VT_SCENARIO_TYPE_TYPE, static_cast<uint8_t>(scenario_type_type), 0);
  }
  void add_scenario_type(::flatbuffers::Offset<void> scenario_type) {
    fbb_.AddOffset(ScenarioDef::VT_SCENARIO_TYPE, scenario_type);
  }
  explicit ScenarioDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ScenarioDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ScenarioDef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ScenarioDef> CreateScenarioDef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> display_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    aim::ScenarioDefType scenario_type_type = aim::ScenarioDefType_NONE,
    ::flatbuffers::Offset<void> scenario_type = 0) {
  ScenarioDefBuilder builder_(_fbb);
  builder_.add_scenario_type(scenario_type);
  builder_.add_id(id);
  builder_.add_display_name(display_name);
  builder_.add_scenario_type_type(scenario_type_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ScenarioDef> CreateScenarioDefDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *display_name = nullptr,
    const char *id = nullptr,
    aim::ScenarioDefType scenario_type_type = aim::ScenarioDefType_NONE,
    ::flatbuffers::Offset<void> scenario_type = 0) {
  auto display_name__ = display_name ? _fbb.CreateString(display_name) : 0;
  auto id__ = id ? _fbb.CreateString(id) : 0;
  return aim::CreateScenarioDef(
      _fbb,
      display_name__,
      id__,
      scenario_type_type,
      scenario_type);
}

::flatbuffers::Offset<ScenarioDef> CreateScenarioDef(::flatbuffers::FlatBufferBuilder &_fbb, const ScenarioDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline RoomDefT *RoomDef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoomDefT>(new RoomDefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoomDef::UnPackTo(RoomDefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = width(); _o->width = _e; }
  { auto _e = height(); _o->height = _e; }
  { auto _e = camera_height_percent(); _o->camera_height_percent = _e; }
  { auto _e = camera_distance(); _o->camera_distance = _e; }
}

inline ::flatbuffers::Offset<RoomDef> RoomDef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RoomDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoomDef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RoomDef> CreateRoomDef(::flatbuffers::FlatBufferBuilder &_fbb, const RoomDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RoomDefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _camera_height_percent = _o->camera_height_percent;
  auto _camera_distance = _o->camera_distance;
  return aim::CreateRoomDef(
      _fbb,
      _width,
      _height,
      _camera_height_percent,
      _camera_distance);
}

inline SimpleStaticScenarioDefT::SimpleStaticScenarioDefT(const SimpleStaticScenarioDefT &o)
      : room((o.room) ? new aim::RoomDefT(*o.room) : nullptr),
        num_targets(o.num_targets),
        target_radius(o.target_radius) {
}

inline SimpleStaticScenarioDefT &SimpleStaticScenarioDefT::operator=(SimpleStaticScenarioDefT o) FLATBUFFERS_NOEXCEPT {
  std::swap(room, o.room);
  std::swap(num_targets, o.num_targets);
  std::swap(target_radius, o.target_radius);
  return *this;
}

inline SimpleStaticScenarioDefT *SimpleStaticScenarioDef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SimpleStaticScenarioDefT>(new SimpleStaticScenarioDefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SimpleStaticScenarioDef::UnPackTo(SimpleStaticScenarioDefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = room(); if (_e) { if(_o->room) { _e->UnPackTo(_o->room.get(), _resolver); } else { _o->room = std::unique_ptr<aim::RoomDefT>(_e->UnPack(_resolver)); } } else if (_o->room) { _o->room.reset(); } }
  { auto _e = num_targets(); _o->num_targets = _e; }
  { auto _e = target_radius(); _o->target_radius = _e; }
}

inline ::flatbuffers::Offset<SimpleStaticScenarioDef> SimpleStaticScenarioDef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SimpleStaticScenarioDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSimpleStaticScenarioDef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SimpleStaticScenarioDef> CreateSimpleStaticScenarioDef(::flatbuffers::FlatBufferBuilder &_fbb, const SimpleStaticScenarioDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SimpleStaticScenarioDefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _room = _o->room ? CreateRoomDef(_fbb, _o->room.get(), _rehasher) : 0;
  auto _num_targets = _o->num_targets;
  auto _target_radius = _o->target_radius;
  return aim::CreateSimpleStaticScenarioDef(
      _fbb,
      _room,
      _num_targets,
      _target_radius);
}

inline ScenarioDefT *ScenarioDef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScenarioDefT>(new ScenarioDefT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScenarioDef::UnPackTo(ScenarioDefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = display_name(); if (_e) _o->display_name = _e->str(); }
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = scenario_type_type(); _o->scenario_type.type = _e; }
  { auto _e = scenario_type(); if (_e) _o->scenario_type.value = aim::ScenarioDefTypeUnion::UnPack(_e, scenario_type_type(), _resolver); }
}

inline ::flatbuffers::Offset<ScenarioDef> ScenarioDef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ScenarioDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScenarioDef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ScenarioDef> CreateScenarioDef(::flatbuffers::FlatBufferBuilder &_fbb, const ScenarioDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ScenarioDefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _display_name = _o->display_name.empty() ? 0 : _fbb.CreateString(_o->display_name);
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _scenario_type_type = _o->scenario_type.type;
  auto _scenario_type = _o->scenario_type.Pack(_fbb);
  return aim::CreateScenarioDef(
      _fbb,
      _display_name,
      _id,
      _scenario_type_type,
      _scenario_type);
}

inline bool VerifyScenarioDefType(::flatbuffers::Verifier &verifier, const void *obj, ScenarioDefType type) {
  switch (type) {
    case ScenarioDefType_NONE: {
      return true;
    }
    case ScenarioDefType_simple_static: {
      auto ptr = reinterpret_cast<const aim::SimpleStaticScenarioDef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyScenarioDefTypeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScenarioDefType(
        verifier,  values->Get(i), types->GetEnum<ScenarioDefType>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ScenarioDefTypeUnion::UnPack(const void *obj, ScenarioDefType type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ScenarioDefType_simple_static: {
      auto ptr = reinterpret_cast<const aim::SimpleStaticScenarioDef *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ScenarioDefTypeUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ScenarioDefType_simple_static: {
      auto ptr = reinterpret_cast<const aim::SimpleStaticScenarioDefT *>(value);
      return CreateSimpleStaticScenarioDef(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ScenarioDefTypeUnion::ScenarioDefTypeUnion(const ScenarioDefTypeUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ScenarioDefType_simple_static: {
      value = new aim::SimpleStaticScenarioDefT(*reinterpret_cast<aim::SimpleStaticScenarioDefT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ScenarioDefTypeUnion::Reset() {
  switch (type) {
    case ScenarioDefType_simple_static: {
      auto ptr = reinterpret_cast<aim::SimpleStaticScenarioDefT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ScenarioDefType_NONE;
}

}  // namespace aim

#endif  // FLATBUFFERS_GENERATED_SCENARIODEF_AIM_H_
