// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SETTINGS_AIM_H_
#define FLATBUFFERS_GENERATED_SETTINGS_AIM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace aim {

struct Crosshair;
struct CrosshairBuilder;
struct CrosshairT;

struct DotCrosshair;
struct DotCrosshairBuilder;
struct DotCrosshairT;

struct Settings;
struct SettingsBuilder;
struct SettingsT;

struct SystemSettings;
struct SystemSettingsBuilder;
struct SystemSettingsT;

struct FullSettings;
struct FullSettingsBuilder;
struct FullSettingsT;

struct CrosshairT : public ::flatbuffers::NativeTable {
  typedef Crosshair TableType;
  std::unique_ptr<aim::DotCrosshairT> dot{};
  CrosshairT() = default;
  CrosshairT(const CrosshairT &o);
  CrosshairT(CrosshairT&&) FLATBUFFERS_NOEXCEPT = default;
  CrosshairT &operator=(CrosshairT o) FLATBUFFERS_NOEXCEPT;
};

struct Crosshair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CrosshairT NativeTableType;
  typedef CrosshairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOT = 4
  };
  const aim::DotCrosshair *dot() const {
    return GetPointer<const aim::DotCrosshair *>(VT_DOT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOT) &&
           verifier.VerifyTable(dot()) &&
           verifier.EndTable();
  }
  CrosshairT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Crosshair> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CrosshairBuilder {
  typedef Crosshair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dot(::flatbuffers::Offset<aim::DotCrosshair> dot) {
    fbb_.AddOffset(Crosshair::VT_DOT, dot);
  }
  explicit CrosshairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Crosshair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Crosshair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Crosshair> CreateCrosshair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<aim::DotCrosshair> dot = 0) {
  CrosshairBuilder builder_(_fbb);
  builder_.add_dot(dot);
  return builder_.Finish();
}

::flatbuffers::Offset<Crosshair> CreateCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DotCrosshairT : public ::flatbuffers::NativeTable {
  typedef DotCrosshair TableType;
  float dot_size = 0.0f;
  bool draw_outline = false;
  std::unique_ptr<aim::StoredRgb> dot_color{};
  std::unique_ptr<aim::StoredRgb> outline_color{};
  DotCrosshairT() = default;
  DotCrosshairT(const DotCrosshairT &o);
  DotCrosshairT(DotCrosshairT&&) FLATBUFFERS_NOEXCEPT = default;
  DotCrosshairT &operator=(DotCrosshairT o) FLATBUFFERS_NOEXCEPT;
};

struct DotCrosshair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DotCrosshairT NativeTableType;
  typedef DotCrosshairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOT_SIZE = 4,
    VT_DRAW_OUTLINE = 6,
    VT_DOT_COLOR = 8,
    VT_OUTLINE_COLOR = 10
  };
  float dot_size() const {
    return GetField<float>(VT_DOT_SIZE, 0.0f);
  }
  bool draw_outline() const {
    return GetField<uint8_t>(VT_DRAW_OUTLINE, 0) != 0;
  }
  const aim::StoredRgb *dot_color() const {
    return GetStruct<const aim::StoredRgb *>(VT_DOT_COLOR);
  }
  const aim::StoredRgb *outline_color() const {
    return GetStruct<const aim::StoredRgb *>(VT_OUTLINE_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DOT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DRAW_OUTLINE, 1) &&
           VerifyField<aim::StoredRgb>(verifier, VT_DOT_COLOR, 1) &&
           VerifyField<aim::StoredRgb>(verifier, VT_OUTLINE_COLOR, 1) &&
           verifier.EndTable();
  }
  DotCrosshairT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DotCrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DotCrosshair> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DotCrosshairBuilder {
  typedef DotCrosshair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dot_size(float dot_size) {
    fbb_.AddElement<float>(DotCrosshair::VT_DOT_SIZE, dot_size, 0.0f);
  }
  void add_draw_outline(bool draw_outline) {
    fbb_.AddElement<uint8_t>(DotCrosshair::VT_DRAW_OUTLINE, static_cast<uint8_t>(draw_outline), 0);
  }
  void add_dot_color(const aim::StoredRgb *dot_color) {
    fbb_.AddStruct(DotCrosshair::VT_DOT_COLOR, dot_color);
  }
  void add_outline_color(const aim::StoredRgb *outline_color) {
    fbb_.AddStruct(DotCrosshair::VT_OUTLINE_COLOR, outline_color);
  }
  explicit DotCrosshairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DotCrosshair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DotCrosshair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float dot_size = 0.0f,
    bool draw_outline = false,
    const aim::StoredRgb *dot_color = nullptr,
    const aim::StoredRgb *outline_color = nullptr) {
  DotCrosshairBuilder builder_(_fbb);
  builder_.add_outline_color(outline_color);
  builder_.add_dot_color(dot_color);
  builder_.add_dot_size(dot_size);
  builder_.add_draw_outline(draw_outline);
  return builder_.Finish();
}

::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SettingsT : public ::flatbuffers::NativeTable {
  typedef Settings TableType;
  std::string name{};
  std::unique_ptr<aim::CrosshairT> crosshair{};
  float cm_per_360 = 0.0f;
  std::string theme_name{};
  SettingsT() = default;
  SettingsT(const SettingsT &o);
  SettingsT(SettingsT&&) FLATBUFFERS_NOEXCEPT = default;
  SettingsT &operator=(SettingsT o) FLATBUFFERS_NOEXCEPT;
};

struct Settings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SettingsT NativeTableType;
  typedef SettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CROSSHAIR = 6,
    VT_CM_PER_360 = 8,
    VT_THEME_NAME = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const aim::Crosshair *crosshair() const {
    return GetPointer<const aim::Crosshair *>(VT_CROSSHAIR);
  }
  float cm_per_360() const {
    return GetField<float>(VT_CM_PER_360, 0.0f);
  }
  const ::flatbuffers::String *theme_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_THEME_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CROSSHAIR) &&
           verifier.VerifyTable(crosshair()) &&
           VerifyField<float>(verifier, VT_CM_PER_360, 4) &&
           VerifyOffset(verifier, VT_THEME_NAME) &&
           verifier.VerifyString(theme_name()) &&
           verifier.EndTable();
  }
  SettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Settings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SettingsBuilder {
  typedef Settings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Settings::VT_NAME, name);
  }
  void add_crosshair(::flatbuffers::Offset<aim::Crosshair> crosshair) {
    fbb_.AddOffset(Settings::VT_CROSSHAIR, crosshair);
  }
  void add_cm_per_360(float cm_per_360) {
    fbb_.AddElement<float>(Settings::VT_CM_PER_360, cm_per_360, 0.0f);
  }
  void add_theme_name(::flatbuffers::Offset<::flatbuffers::String> theme_name) {
    fbb_.AddOffset(Settings::VT_THEME_NAME, theme_name);
  }
  explicit SettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Settings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Settings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Settings> CreateSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<aim::Crosshair> crosshair = 0,
    float cm_per_360 = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> theme_name = 0) {
  SettingsBuilder builder_(_fbb);
  builder_.add_theme_name(theme_name);
  builder_.add_cm_per_360(cm_per_360);
  builder_.add_crosshair(crosshair);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Settings> CreateSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<aim::Crosshair> crosshair = 0,
    float cm_per_360 = 0.0f,
    const char *theme_name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto theme_name__ = theme_name ? _fbb.CreateString(theme_name) : 0;
  return aim::CreateSettings(
      _fbb,
      name__,
      crosshair,
      cm_per_360,
      theme_name__);
}

::flatbuffers::Offset<Settings> CreateSettings(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SystemSettingsT : public ::flatbuffers::NativeTable {
  typedef SystemSettings TableType;
  float dpi = 0.0f;
};

struct SystemSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SystemSettingsT NativeTableType;
  typedef SystemSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DPI = 4
  };
  float dpi() const {
    return GetField<float>(VT_DPI, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DPI, 4) &&
           verifier.EndTable();
  }
  SystemSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SystemSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SystemSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SystemSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SystemSettingsBuilder {
  typedef SystemSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dpi(float dpi) {
    fbb_.AddElement<float>(SystemSettings::VT_DPI, dpi, 0.0f);
  }
  explicit SystemSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SystemSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SystemSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SystemSettings> CreateSystemSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float dpi = 0.0f) {
  SystemSettingsBuilder builder_(_fbb);
  builder_.add_dpi(dpi);
  return builder_.Finish();
}

::flatbuffers::Offset<SystemSettings> CreateSystemSettings(::flatbuffers::FlatBufferBuilder &_fbb, const SystemSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FullSettingsT : public ::flatbuffers::NativeTable {
  typedef FullSettings TableType;
  std::unique_ptr<aim::SystemSettingsT> system_settings{};
  std::string current_settings{};
  std::vector<std::unique_ptr<aim::SettingsT>> settings_list{};
  FullSettingsT() = default;
  FullSettingsT(const FullSettingsT &o);
  FullSettingsT(FullSettingsT&&) FLATBUFFERS_NOEXCEPT = default;
  FullSettingsT &operator=(FullSettingsT o) FLATBUFFERS_NOEXCEPT;
};

struct FullSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FullSettingsT NativeTableType;
  typedef FullSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_SETTINGS = 4,
    VT_CURRENT_SETTINGS = 6,
    VT_SETTINGS_LIST = 8
  };
  const aim::SystemSettings *system_settings() const {
    return GetPointer<const aim::SystemSettings *>(VT_SYSTEM_SETTINGS);
  }
  const ::flatbuffers::String *current_settings() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENT_SETTINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<aim::Settings>> *settings_list() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<aim::Settings>> *>(VT_SETTINGS_LIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYSTEM_SETTINGS) &&
           verifier.VerifyTable(system_settings()) &&
           VerifyOffset(verifier, VT_CURRENT_SETTINGS) &&
           verifier.VerifyString(current_settings()) &&
           VerifyOffset(verifier, VT_SETTINGS_LIST) &&
           verifier.VerifyVector(settings_list()) &&
           verifier.VerifyVectorOfTables(settings_list()) &&
           verifier.EndTable();
  }
  FullSettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FullSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FullSettings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FullSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FullSettingsBuilder {
  typedef FullSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_system_settings(::flatbuffers::Offset<aim::SystemSettings> system_settings) {
    fbb_.AddOffset(FullSettings::VT_SYSTEM_SETTINGS, system_settings);
  }
  void add_current_settings(::flatbuffers::Offset<::flatbuffers::String> current_settings) {
    fbb_.AddOffset(FullSettings::VT_CURRENT_SETTINGS, current_settings);
  }
  void add_settings_list(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<aim::Settings>>> settings_list) {
    fbb_.AddOffset(FullSettings::VT_SETTINGS_LIST, settings_list);
  }
  explicit FullSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FullSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FullSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FullSettings> CreateFullSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<aim::SystemSettings> system_settings = 0,
    ::flatbuffers::Offset<::flatbuffers::String> current_settings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<aim::Settings>>> settings_list = 0) {
  FullSettingsBuilder builder_(_fbb);
  builder_.add_settings_list(settings_list);
  builder_.add_current_settings(current_settings);
  builder_.add_system_settings(system_settings);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FullSettings> CreateFullSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<aim::SystemSettings> system_settings = 0,
    const char *current_settings = nullptr,
    const std::vector<::flatbuffers::Offset<aim::Settings>> *settings_list = nullptr) {
  auto current_settings__ = current_settings ? _fbb.CreateString(current_settings) : 0;
  auto settings_list__ = settings_list ? _fbb.CreateVector<::flatbuffers::Offset<aim::Settings>>(*settings_list) : 0;
  return aim::CreateFullSettings(
      _fbb,
      system_settings,
      current_settings__,
      settings_list__);
}

::flatbuffers::Offset<FullSettings> CreateFullSettings(::flatbuffers::FlatBufferBuilder &_fbb, const FullSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CrosshairT::CrosshairT(const CrosshairT &o)
      : dot((o.dot) ? new aim::DotCrosshairT(*o.dot) : nullptr) {
}

inline CrosshairT &CrosshairT::operator=(CrosshairT o) FLATBUFFERS_NOEXCEPT {
  std::swap(dot, o.dot);
  return *this;
}

inline CrosshairT *Crosshair::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CrosshairT>(new CrosshairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Crosshair::UnPackTo(CrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dot(); if (_e) { if(_o->dot) { _e->UnPackTo(_o->dot.get(), _resolver); } else { _o->dot = std::unique_ptr<aim::DotCrosshairT>(_e->UnPack(_resolver)); } } else if (_o->dot) { _o->dot.reset(); } }
}

inline ::flatbuffers::Offset<Crosshair> Crosshair::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCrosshair(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Crosshair> CreateCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CrosshairT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dot = _o->dot ? CreateDotCrosshair(_fbb, _o->dot.get(), _rehasher) : 0;
  return aim::CreateCrosshair(
      _fbb,
      _dot);
}

inline DotCrosshairT::DotCrosshairT(const DotCrosshairT &o)
      : dot_size(o.dot_size),
        draw_outline(o.draw_outline),
        dot_color((o.dot_color) ? new aim::StoredRgb(*o.dot_color) : nullptr),
        outline_color((o.outline_color) ? new aim::StoredRgb(*o.outline_color) : nullptr) {
}

inline DotCrosshairT &DotCrosshairT::operator=(DotCrosshairT o) FLATBUFFERS_NOEXCEPT {
  std::swap(dot_size, o.dot_size);
  std::swap(draw_outline, o.draw_outline);
  std::swap(dot_color, o.dot_color);
  std::swap(outline_color, o.outline_color);
  return *this;
}

inline DotCrosshairT *DotCrosshair::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DotCrosshairT>(new DotCrosshairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DotCrosshair::UnPackTo(DotCrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dot_size(); _o->dot_size = _e; }
  { auto _e = draw_outline(); _o->draw_outline = _e; }
  { auto _e = dot_color(); if (_e) _o->dot_color = std::unique_ptr<aim::StoredRgb>(new aim::StoredRgb(*_e)); }
  { auto _e = outline_color(); if (_e) _o->outline_color = std::unique_ptr<aim::StoredRgb>(new aim::StoredRgb(*_e)); }
}

inline ::flatbuffers::Offset<DotCrosshair> DotCrosshair::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDotCrosshair(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DotCrosshairT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dot_size = _o->dot_size;
  auto _draw_outline = _o->draw_outline;
  auto _dot_color = _o->dot_color ? _o->dot_color.get() : nullptr;
  auto _outline_color = _o->outline_color ? _o->outline_color.get() : nullptr;
  return aim::CreateDotCrosshair(
      _fbb,
      _dot_size,
      _draw_outline,
      _dot_color,
      _outline_color);
}

inline SettingsT::SettingsT(const SettingsT &o)
      : name(o.name),
        crosshair((o.crosshair) ? new aim::CrosshairT(*o.crosshair) : nullptr),
        cm_per_360(o.cm_per_360),
        theme_name(o.theme_name) {
}

inline SettingsT &SettingsT::operator=(SettingsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(crosshair, o.crosshair);
  std::swap(cm_per_360, o.cm_per_360);
  std::swap(theme_name, o.theme_name);
  return *this;
}

inline SettingsT *Settings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SettingsT>(new SettingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Settings::UnPackTo(SettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = crosshair(); if (_e) { if(_o->crosshair) { _e->UnPackTo(_o->crosshair.get(), _resolver); } else { _o->crosshair = std::unique_ptr<aim::CrosshairT>(_e->UnPack(_resolver)); } } else if (_o->crosshair) { _o->crosshair.reset(); } }
  { auto _e = cm_per_360(); _o->cm_per_360 = _e; }
  { auto _e = theme_name(); if (_e) _o->theme_name = _e->str(); }
}

inline ::flatbuffers::Offset<Settings> Settings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSettings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Settings> CreateSettings(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _crosshair = _o->crosshair ? CreateCrosshair(_fbb, _o->crosshair.get(), _rehasher) : 0;
  auto _cm_per_360 = _o->cm_per_360;
  auto _theme_name = _o->theme_name.empty() ? 0 : _fbb.CreateString(_o->theme_name);
  return aim::CreateSettings(
      _fbb,
      _name,
      _crosshair,
      _cm_per_360,
      _theme_name);
}

inline SystemSettingsT *SystemSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SystemSettingsT>(new SystemSettingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SystemSettings::UnPackTo(SystemSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dpi(); _o->dpi = _e; }
}

inline ::flatbuffers::Offset<SystemSettings> SystemSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SystemSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSystemSettings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SystemSettings> CreateSystemSettings(::flatbuffers::FlatBufferBuilder &_fbb, const SystemSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SystemSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dpi = _o->dpi;
  return aim::CreateSystemSettings(
      _fbb,
      _dpi);
}

inline FullSettingsT::FullSettingsT(const FullSettingsT &o)
      : system_settings((o.system_settings) ? new aim::SystemSettingsT(*o.system_settings) : nullptr),
        current_settings(o.current_settings) {
  settings_list.reserve(o.settings_list.size());
  for (const auto &settings_list_ : o.settings_list) { settings_list.emplace_back((settings_list_) ? new aim::SettingsT(*settings_list_) : nullptr); }
}

inline FullSettingsT &FullSettingsT::operator=(FullSettingsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(system_settings, o.system_settings);
  std::swap(current_settings, o.current_settings);
  std::swap(settings_list, o.settings_list);
  return *this;
}

inline FullSettingsT *FullSettings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FullSettingsT>(new FullSettingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FullSettings::UnPackTo(FullSettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = system_settings(); if (_e) { if(_o->system_settings) { _e->UnPackTo(_o->system_settings.get(), _resolver); } else { _o->system_settings = std::unique_ptr<aim::SystemSettingsT>(_e->UnPack(_resolver)); } } else if (_o->system_settings) { _o->system_settings.reset(); } }
  { auto _e = current_settings(); if (_e) _o->current_settings = _e->str(); }
  { auto _e = settings_list(); if (_e) { _o->settings_list.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->settings_list[_i]) { _e->Get(_i)->UnPackTo(_o->settings_list[_i].get(), _resolver); } else { _o->settings_list[_i] = std::unique_ptr<aim::SettingsT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->settings_list.resize(0); } }
}

inline ::flatbuffers::Offset<FullSettings> FullSettings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FullSettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFullSettings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FullSettings> CreateFullSettings(::flatbuffers::FlatBufferBuilder &_fbb, const FullSettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FullSettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _system_settings = _o->system_settings ? CreateSystemSettings(_fbb, _o->system_settings.get(), _rehasher) : 0;
  auto _current_settings = _o->current_settings.empty() ? 0 : _fbb.CreateString(_o->current_settings);
  auto _settings_list = _o->settings_list.size() ? _fbb.CreateVector<::flatbuffers::Offset<aim::Settings>> (_o->settings_list.size(), [](size_t i, _VectorArgs *__va) { return CreateSettings(*__va->__fbb, __va->__o->settings_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return aim::CreateFullSettings(
      _fbb,
      _system_settings,
      _current_settings,
      _settings_list);
}

inline const aim::FullSettings *GetFullSettings(const void *buf) {
  return ::flatbuffers::GetRoot<aim::FullSettings>(buf);
}

inline const aim::FullSettings *GetSizePrefixedFullSettings(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<aim::FullSettings>(buf);
}

inline const char *FullSettingsIdentifier() {
  return "SETG";
}

inline bool FullSettingsBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, FullSettingsIdentifier());
}

inline bool SizePrefixedFullSettingsBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, FullSettingsIdentifier(), true);
}

inline bool VerifyFullSettingsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<aim::FullSettings>(FullSettingsIdentifier());
}

inline bool VerifySizePrefixedFullSettingsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<aim::FullSettings>(FullSettingsIdentifier());
}

inline void FinishFullSettingsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<aim::FullSettings> root) {
  fbb.Finish(root, FullSettingsIdentifier());
}

inline void FinishSizePrefixedFullSettingsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<aim::FullSettings> root) {
  fbb.FinishSizePrefixed(root, FullSettingsIdentifier());
}

inline std::unique_ptr<aim::FullSettingsT> UnPackFullSettings(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<aim::FullSettingsT>(GetFullSettings(buf)->UnPack(res));
}

inline std::unique_ptr<aim::FullSettingsT> UnPackSizePrefixedFullSettings(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<aim::FullSettingsT>(GetSizePrefixedFullSettings(buf)->UnPack(res));
}

}  // namespace aim

#endif  // FLATBUFFERS_GENERATED_SETTINGS_AIM_H_
