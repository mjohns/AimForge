// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SETTINGS_AIM_H_
#define FLATBUFFERS_GENERATED_SETTINGS_AIM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace aim {

struct Crosshair;
struct CrosshairBuilder;
struct CrosshairT;

struct DotCrosshair;
struct DotCrosshairBuilder;
struct DotCrosshairT;

struct CrosshairT : public ::flatbuffers::NativeTable {
  typedef Crosshair TableType;
  std::unique_ptr<aim::DotCrosshairT> dot{};
  CrosshairT() = default;
  CrosshairT(const CrosshairT &o);
  CrosshairT(CrosshairT&&) FLATBUFFERS_NOEXCEPT = default;
  CrosshairT &operator=(CrosshairT o) FLATBUFFERS_NOEXCEPT;
};

struct Crosshair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CrosshairT NativeTableType;
  typedef CrosshairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOT = 4
  };
  const aim::DotCrosshair *dot() const {
    return GetPointer<const aim::DotCrosshair *>(VT_DOT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOT) &&
           verifier.VerifyTable(dot()) &&
           verifier.EndTable();
  }
  CrosshairT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Crosshair> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CrosshairBuilder {
  typedef Crosshair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dot(::flatbuffers::Offset<aim::DotCrosshair> dot) {
    fbb_.AddOffset(Crosshair::VT_DOT, dot);
  }
  explicit CrosshairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Crosshair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Crosshair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Crosshair> CreateCrosshair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<aim::DotCrosshair> dot = 0) {
  CrosshairBuilder builder_(_fbb);
  builder_.add_dot(dot);
  return builder_.Finish();
}

::flatbuffers::Offset<Crosshair> CreateCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DotCrosshairT : public ::flatbuffers::NativeTable {
  typedef DotCrosshair TableType;
  float dot_size = 0.0f;
  bool draw_outline = false;
  std::unique_ptr<aim::StoredRgb> dot_color{};
  std::unique_ptr<aim::StoredRgb> outline_color{};
  DotCrosshairT() = default;
  DotCrosshairT(const DotCrosshairT &o);
  DotCrosshairT(DotCrosshairT&&) FLATBUFFERS_NOEXCEPT = default;
  DotCrosshairT &operator=(DotCrosshairT o) FLATBUFFERS_NOEXCEPT;
};

struct DotCrosshair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DotCrosshairT NativeTableType;
  typedef DotCrosshairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOT_SIZE = 4,
    VT_DRAW_OUTLINE = 6,
    VT_DOT_COLOR = 8,
    VT_OUTLINE_COLOR = 10
  };
  float dot_size() const {
    return GetField<float>(VT_DOT_SIZE, 0.0f);
  }
  bool draw_outline() const {
    return GetField<uint8_t>(VT_DRAW_OUTLINE, 0) != 0;
  }
  const aim::StoredRgb *dot_color() const {
    return GetStruct<const aim::StoredRgb *>(VT_DOT_COLOR);
  }
  const aim::StoredRgb *outline_color() const {
    return GetStruct<const aim::StoredRgb *>(VT_OUTLINE_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DOT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DRAW_OUTLINE, 1) &&
           VerifyField<aim::StoredRgb>(verifier, VT_DOT_COLOR, 1) &&
           VerifyField<aim::StoredRgb>(verifier, VT_OUTLINE_COLOR, 1) &&
           verifier.EndTable();
  }
  DotCrosshairT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DotCrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DotCrosshair> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DotCrosshairBuilder {
  typedef DotCrosshair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dot_size(float dot_size) {
    fbb_.AddElement<float>(DotCrosshair::VT_DOT_SIZE, dot_size, 0.0f);
  }
  void add_draw_outline(bool draw_outline) {
    fbb_.AddElement<uint8_t>(DotCrosshair::VT_DRAW_OUTLINE, static_cast<uint8_t>(draw_outline), 0);
  }
  void add_dot_color(const aim::StoredRgb *dot_color) {
    fbb_.AddStruct(DotCrosshair::VT_DOT_COLOR, dot_color);
  }
  void add_outline_color(const aim::StoredRgb *outline_color) {
    fbb_.AddStruct(DotCrosshair::VT_OUTLINE_COLOR, outline_color);
  }
  explicit DotCrosshairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DotCrosshair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DotCrosshair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float dot_size = 0.0f,
    bool draw_outline = false,
    const aim::StoredRgb *dot_color = nullptr,
    const aim::StoredRgb *outline_color = nullptr) {
  DotCrosshairBuilder builder_(_fbb);
  builder_.add_outline_color(outline_color);
  builder_.add_dot_color(dot_color);
  builder_.add_dot_size(dot_size);
  builder_.add_draw_outline(draw_outline);
  return builder_.Finish();
}

::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CrosshairT::CrosshairT(const CrosshairT &o)
      : dot((o.dot) ? new aim::DotCrosshairT(*o.dot) : nullptr) {
}

inline CrosshairT &CrosshairT::operator=(CrosshairT o) FLATBUFFERS_NOEXCEPT {
  std::swap(dot, o.dot);
  return *this;
}

inline CrosshairT *Crosshair::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CrosshairT>(new CrosshairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Crosshair::UnPackTo(CrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dot(); if (_e) { if(_o->dot) { _e->UnPackTo(_o->dot.get(), _resolver); } else { _o->dot = std::unique_ptr<aim::DotCrosshairT>(_e->UnPack(_resolver)); } } else if (_o->dot) { _o->dot.reset(); } }
}

inline ::flatbuffers::Offset<Crosshair> Crosshair::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCrosshair(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Crosshair> CreateCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CrosshairT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dot = _o->dot ? CreateDotCrosshair(_fbb, _o->dot.get(), _rehasher) : 0;
  return aim::CreateCrosshair(
      _fbb,
      _dot);
}

inline DotCrosshairT::DotCrosshairT(const DotCrosshairT &o)
      : dot_size(o.dot_size),
        draw_outline(o.draw_outline),
        dot_color((o.dot_color) ? new aim::StoredRgb(*o.dot_color) : nullptr),
        outline_color((o.outline_color) ? new aim::StoredRgb(*o.outline_color) : nullptr) {
}

inline DotCrosshairT &DotCrosshairT::operator=(DotCrosshairT o) FLATBUFFERS_NOEXCEPT {
  std::swap(dot_size, o.dot_size);
  std::swap(draw_outline, o.draw_outline);
  std::swap(dot_color, o.dot_color);
  std::swap(outline_color, o.outline_color);
  return *this;
}

inline DotCrosshairT *DotCrosshair::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DotCrosshairT>(new DotCrosshairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DotCrosshair::UnPackTo(DotCrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dot_size(); _o->dot_size = _e; }
  { auto _e = draw_outline(); _o->draw_outline = _e; }
  { auto _e = dot_color(); if (_e) _o->dot_color = std::unique_ptr<aim::StoredRgb>(new aim::StoredRgb(*_e)); }
  { auto _e = outline_color(); if (_e) _o->outline_color = std::unique_ptr<aim::StoredRgb>(new aim::StoredRgb(*_e)); }
}

inline ::flatbuffers::Offset<DotCrosshair> DotCrosshair::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDotCrosshair(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DotCrosshairT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dot_size = _o->dot_size;
  auto _draw_outline = _o->draw_outline;
  auto _dot_color = _o->dot_color ? _o->dot_color.get() : nullptr;
  auto _outline_color = _o->outline_color ? _o->outline_color.get() : nullptr;
  return aim::CreateDotCrosshair(
      _fbb,
      _dot_size,
      _draw_outline,
      _dot_color,
      _outline_color);
}

}  // namespace aim

#endif  // FLATBUFFERS_GENERATED_SETTINGS_AIM_H_
