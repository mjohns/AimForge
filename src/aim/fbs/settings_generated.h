// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SETTINGS_AIM_H_
#define FLATBUFFERS_GENERATED_SETTINGS_AIM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace aim {

struct Crosshair;
struct CrosshairBuilder;
struct CrosshairT;

struct DotCrosshair;
struct DotCrosshairBuilder;
struct DotCrosshairT;

struct Settings;
struct SettingsBuilder;
struct SettingsT;

struct CrosshairT : public ::flatbuffers::NativeTable {
  typedef Crosshair TableType;
  std::unique_ptr<aim::DotCrosshairT> dot{};
  CrosshairT() = default;
  CrosshairT(const CrosshairT &o);
  CrosshairT(CrosshairT&&) FLATBUFFERS_NOEXCEPT = default;
  CrosshairT &operator=(CrosshairT o) FLATBUFFERS_NOEXCEPT;
};

struct Crosshair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CrosshairT NativeTableType;
  typedef CrosshairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOT = 4
  };
  const aim::DotCrosshair *dot() const {
    return GetPointer<const aim::DotCrosshair *>(VT_DOT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOT) &&
           verifier.VerifyTable(dot()) &&
           verifier.EndTable();
  }
  CrosshairT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Crosshair> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CrosshairBuilder {
  typedef Crosshair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dot(::flatbuffers::Offset<aim::DotCrosshair> dot) {
    fbb_.AddOffset(Crosshair::VT_DOT, dot);
  }
  explicit CrosshairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Crosshair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Crosshair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Crosshair> CreateCrosshair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<aim::DotCrosshair> dot = 0) {
  CrosshairBuilder builder_(_fbb);
  builder_.add_dot(dot);
  return builder_.Finish();
}

::flatbuffers::Offset<Crosshair> CreateCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DotCrosshairT : public ::flatbuffers::NativeTable {
  typedef DotCrosshair TableType;
  float dot_size = 0.0f;
  bool draw_outline = false;
  std::unique_ptr<aim::StoredRgb> dot_color{};
  std::unique_ptr<aim::StoredRgb> outline_color{};
  DotCrosshairT() = default;
  DotCrosshairT(const DotCrosshairT &o);
  DotCrosshairT(DotCrosshairT&&) FLATBUFFERS_NOEXCEPT = default;
  DotCrosshairT &operator=(DotCrosshairT o) FLATBUFFERS_NOEXCEPT;
};

struct DotCrosshair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DotCrosshairT NativeTableType;
  typedef DotCrosshairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOT_SIZE = 4,
    VT_DRAW_OUTLINE = 6,
    VT_DOT_COLOR = 8,
    VT_OUTLINE_COLOR = 10
  };
  float dot_size() const {
    return GetField<float>(VT_DOT_SIZE, 0.0f);
  }
  bool draw_outline() const {
    return GetField<uint8_t>(VT_DRAW_OUTLINE, 0) != 0;
  }
  const aim::StoredRgb *dot_color() const {
    return GetStruct<const aim::StoredRgb *>(VT_DOT_COLOR);
  }
  const aim::StoredRgb *outline_color() const {
    return GetStruct<const aim::StoredRgb *>(VT_OUTLINE_COLOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DOT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DRAW_OUTLINE, 1) &&
           VerifyField<aim::StoredRgb>(verifier, VT_DOT_COLOR, 1) &&
           VerifyField<aim::StoredRgb>(verifier, VT_OUTLINE_COLOR, 1) &&
           verifier.EndTable();
  }
  DotCrosshairT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DotCrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DotCrosshair> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DotCrosshairBuilder {
  typedef DotCrosshair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dot_size(float dot_size) {
    fbb_.AddElement<float>(DotCrosshair::VT_DOT_SIZE, dot_size, 0.0f);
  }
  void add_draw_outline(bool draw_outline) {
    fbb_.AddElement<uint8_t>(DotCrosshair::VT_DRAW_OUTLINE, static_cast<uint8_t>(draw_outline), 0);
  }
  void add_dot_color(const aim::StoredRgb *dot_color) {
    fbb_.AddStruct(DotCrosshair::VT_DOT_COLOR, dot_color);
  }
  void add_outline_color(const aim::StoredRgb *outline_color) {
    fbb_.AddStruct(DotCrosshair::VT_OUTLINE_COLOR, outline_color);
  }
  explicit DotCrosshairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DotCrosshair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DotCrosshair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float dot_size = 0.0f,
    bool draw_outline = false,
    const aim::StoredRgb *dot_color = nullptr,
    const aim::StoredRgb *outline_color = nullptr) {
  DotCrosshairBuilder builder_(_fbb);
  builder_.add_outline_color(outline_color);
  builder_.add_dot_color(dot_color);
  builder_.add_dot_size(dot_size);
  builder_.add_draw_outline(draw_outline);
  return builder_.Finish();
}

::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SettingsT : public ::flatbuffers::NativeTable {
  typedef Settings TableType;
  std::unique_ptr<aim::CrosshairT> crosshair{};
  float cm_per_360 = 0.0f;
  std::string theme_name{};
  SettingsT() = default;
  SettingsT(const SettingsT &o);
  SettingsT(SettingsT&&) FLATBUFFERS_NOEXCEPT = default;
  SettingsT &operator=(SettingsT o) FLATBUFFERS_NOEXCEPT;
};

struct Settings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SettingsT NativeTableType;
  typedef SettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CROSSHAIR = 4,
    VT_CM_PER_360 = 6,
    VT_THEME_NAME = 8
  };
  const aim::Crosshair *crosshair() const {
    return GetPointer<const aim::Crosshair *>(VT_CROSSHAIR);
  }
  float cm_per_360() const {
    return GetField<float>(VT_CM_PER_360, 0.0f);
  }
  const ::flatbuffers::String *theme_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_THEME_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CROSSHAIR) &&
           verifier.VerifyTable(crosshair()) &&
           VerifyField<float>(verifier, VT_CM_PER_360, 4) &&
           VerifyOffset(verifier, VT_THEME_NAME) &&
           verifier.VerifyString(theme_name()) &&
           verifier.EndTable();
  }
  SettingsT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Settings> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SettingsBuilder {
  typedef Settings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_crosshair(::flatbuffers::Offset<aim::Crosshair> crosshair) {
    fbb_.AddOffset(Settings::VT_CROSSHAIR, crosshair);
  }
  void add_cm_per_360(float cm_per_360) {
    fbb_.AddElement<float>(Settings::VT_CM_PER_360, cm_per_360, 0.0f);
  }
  void add_theme_name(::flatbuffers::Offset<::flatbuffers::String> theme_name) {
    fbb_.AddOffset(Settings::VT_THEME_NAME, theme_name);
  }
  explicit SettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Settings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Settings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Settings> CreateSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<aim::Crosshair> crosshair = 0,
    float cm_per_360 = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> theme_name = 0) {
  SettingsBuilder builder_(_fbb);
  builder_.add_theme_name(theme_name);
  builder_.add_cm_per_360(cm_per_360);
  builder_.add_crosshair(crosshair);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Settings> CreateSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<aim::Crosshair> crosshair = 0,
    float cm_per_360 = 0.0f,
    const char *theme_name = nullptr) {
  auto theme_name__ = theme_name ? _fbb.CreateString(theme_name) : 0;
  return aim::CreateSettings(
      _fbb,
      crosshair,
      cm_per_360,
      theme_name__);
}

::flatbuffers::Offset<Settings> CreateSettings(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline CrosshairT::CrosshairT(const CrosshairT &o)
      : dot((o.dot) ? new aim::DotCrosshairT(*o.dot) : nullptr) {
}

inline CrosshairT &CrosshairT::operator=(CrosshairT o) FLATBUFFERS_NOEXCEPT {
  std::swap(dot, o.dot);
  return *this;
}

inline CrosshairT *Crosshair::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CrosshairT>(new CrosshairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Crosshair::UnPackTo(CrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dot(); if (_e) { if(_o->dot) { _e->UnPackTo(_o->dot.get(), _resolver); } else { _o->dot = std::unique_ptr<aim::DotCrosshairT>(_e->UnPack(_resolver)); } } else if (_o->dot) { _o->dot.reset(); } }
}

inline ::flatbuffers::Offset<Crosshair> Crosshair::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCrosshair(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Crosshair> CreateCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const CrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CrosshairT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dot = _o->dot ? CreateDotCrosshair(_fbb, _o->dot.get(), _rehasher) : 0;
  return aim::CreateCrosshair(
      _fbb,
      _dot);
}

inline DotCrosshairT::DotCrosshairT(const DotCrosshairT &o)
      : dot_size(o.dot_size),
        draw_outline(o.draw_outline),
        dot_color((o.dot_color) ? new aim::StoredRgb(*o.dot_color) : nullptr),
        outline_color((o.outline_color) ? new aim::StoredRgb(*o.outline_color) : nullptr) {
}

inline DotCrosshairT &DotCrosshairT::operator=(DotCrosshairT o) FLATBUFFERS_NOEXCEPT {
  std::swap(dot_size, o.dot_size);
  std::swap(draw_outline, o.draw_outline);
  std::swap(dot_color, o.dot_color);
  std::swap(outline_color, o.outline_color);
  return *this;
}

inline DotCrosshairT *DotCrosshair::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DotCrosshairT>(new DotCrosshairT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DotCrosshair::UnPackTo(DotCrosshairT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dot_size(); _o->dot_size = _e; }
  { auto _e = draw_outline(); _o->draw_outline = _e; }
  { auto _e = dot_color(); if (_e) _o->dot_color = std::unique_ptr<aim::StoredRgb>(new aim::StoredRgb(*_e)); }
  { auto _e = outline_color(); if (_e) _o->outline_color = std::unique_ptr<aim::StoredRgb>(new aim::StoredRgb(*_e)); }
}

inline ::flatbuffers::Offset<DotCrosshair> DotCrosshair::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDotCrosshair(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DotCrosshair> CreateDotCrosshair(::flatbuffers::FlatBufferBuilder &_fbb, const DotCrosshairT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DotCrosshairT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dot_size = _o->dot_size;
  auto _draw_outline = _o->draw_outline;
  auto _dot_color = _o->dot_color ? _o->dot_color.get() : nullptr;
  auto _outline_color = _o->outline_color ? _o->outline_color.get() : nullptr;
  return aim::CreateDotCrosshair(
      _fbb,
      _dot_size,
      _draw_outline,
      _dot_color,
      _outline_color);
}

inline SettingsT::SettingsT(const SettingsT &o)
      : crosshair((o.crosshair) ? new aim::CrosshairT(*o.crosshair) : nullptr),
        cm_per_360(o.cm_per_360),
        theme_name(o.theme_name) {
}

inline SettingsT &SettingsT::operator=(SettingsT o) FLATBUFFERS_NOEXCEPT {
  std::swap(crosshair, o.crosshair);
  std::swap(cm_per_360, o.cm_per_360);
  std::swap(theme_name, o.theme_name);
  return *this;
}

inline SettingsT *Settings::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SettingsT>(new SettingsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Settings::UnPackTo(SettingsT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = crosshair(); if (_e) { if(_o->crosshair) { _e->UnPackTo(_o->crosshair.get(), _resolver); } else { _o->crosshair = std::unique_ptr<aim::CrosshairT>(_e->UnPack(_resolver)); } } else if (_o->crosshair) { _o->crosshair.reset(); } }
  { auto _e = cm_per_360(); _o->cm_per_360 = _e; }
  { auto _e = theme_name(); if (_e) _o->theme_name = _e->str(); }
}

inline ::flatbuffers::Offset<Settings> Settings::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSettings(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Settings> CreateSettings(::flatbuffers::FlatBufferBuilder &_fbb, const SettingsT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SettingsT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _crosshair = _o->crosshair ? CreateCrosshair(_fbb, _o->crosshair.get(), _rehasher) : 0;
  auto _cm_per_360 = _o->cm_per_360;
  auto _theme_name = _o->theme_name.empty() ? 0 : _fbb.CreateString(_o->theme_name);
  return aim::CreateSettings(
      _fbb,
      _crosshair,
      _cm_per_360,
      _theme_name);
}

inline const aim::Settings *GetSettings(const void *buf) {
  return ::flatbuffers::GetRoot<aim::Settings>(buf);
}

inline const aim::Settings *GetSizePrefixedSettings(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<aim::Settings>(buf);
}

inline bool VerifySettingsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<aim::Settings>(nullptr);
}

inline bool VerifySizePrefixedSettingsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<aim::Settings>(nullptr);
}

inline void FinishSettingsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<aim::Settings> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSettingsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<aim::Settings> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<aim::SettingsT> UnPackSettings(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<aim::SettingsT>(GetSettings(buf)->UnPack(res));
}

inline std::unique_ptr<aim::SettingsT> UnPackSizePrefixedSettings(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<aim::SettingsT>(GetSizePrefixedSettings(buf)->UnPack(res));
}

}  // namespace aim

#endif  // FLATBUFFERS_GENERATED_SETTINGS_AIM_H_
