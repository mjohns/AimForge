// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REPLAY_AIM_H_
#define FLATBUFFERS_GENERATED_REPLAY_AIM_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 24,
             "Non-compatible flatbuffers version included");

#include "common_generated.h"

namespace aim {

struct PitchYaw;

struct AddTargetEvent;
struct AddTargetEventBuilder;
struct AddTargetEventT;

struct HitTargetEvent;
struct HitTargetEventBuilder;
struct HitTargetEventT;

struct MissTargetEvent;
struct MissTargetEventBuilder;
struct MissTargetEventT;

struct StaticReplay;
struct StaticReplayBuilder;
struct StaticReplayT;

struct ReplayFile;
struct ReplayFileBuilder;
struct ReplayFileT;

enum Replay : uint8_t {
  Replay_NONE = 0,
  Replay_static_replay = 1,
  Replay_MIN = Replay_NONE,
  Replay_MAX = Replay_static_replay
};

inline const Replay (&EnumValuesReplay())[2] {
  static const Replay values[] = {
    Replay_NONE,
    Replay_static_replay
  };
  return values;
}

inline const char * const *EnumNamesReplay() {
  static const char * const names[3] = {
    "NONE",
    "static_replay",
    nullptr
  };
  return names;
}

inline const char *EnumNameReplay(Replay e) {
  if (::flatbuffers::IsOutRange(e, Replay_NONE, Replay_static_replay)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReplay()[index];
}

template<typename T> struct ReplayTraits {
  static const Replay enum_value = Replay_NONE;
};

template<> struct ReplayTraits<aim::StaticReplay> {
  static const Replay enum_value = Replay_static_replay;
};

template<typename T> struct ReplayUnionTraits {
  static const Replay enum_value = Replay_NONE;
};

template<> struct ReplayUnionTraits<aim::StaticReplayT> {
  static const Replay enum_value = Replay_static_replay;
};

struct ReplayUnion {
  Replay type;
  void *value;

  ReplayUnion() : type(Replay_NONE), value(nullptr) {}
  ReplayUnion(ReplayUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Replay_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ReplayUnion(const ReplayUnion &);
  ReplayUnion &operator=(const ReplayUnion &u)
    { ReplayUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ReplayUnion &operator=(ReplayUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ReplayUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ReplayUnionTraits<RT>::enum_value;
    if (type != Replay_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Replay type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  aim::StaticReplayT *Asstatic_replay() {
    return type == Replay_static_replay ?
      reinterpret_cast<aim::StaticReplayT *>(value) : nullptr;
  }
  const aim::StaticReplayT *Asstatic_replay() const {
    return type == Replay_static_replay ?
      reinterpret_cast<const aim::StaticReplayT *>(value) : nullptr;
  }
};

bool VerifyReplay(::flatbuffers::Verifier &verifier, const void *obj, Replay type);
bool VerifyReplayVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PitchYaw FLATBUFFERS_FINAL_CLASS {
 private:
  float pitch_;
  float yaw_;

 public:
  PitchYaw()
      : pitch_(0),
        yaw_(0) {
  }
  PitchYaw(float _pitch, float _yaw)
      : pitch_(::flatbuffers::EndianScalar(_pitch)),
        yaw_(::flatbuffers::EndianScalar(_yaw)) {
  }
  float pitch() const {
    return ::flatbuffers::EndianScalar(pitch_);
  }
  float yaw() const {
    return ::flatbuffers::EndianScalar(yaw_);
  }
};
FLATBUFFERS_STRUCT_END(PitchYaw, 8);

struct AddTargetEventT : public ::flatbuffers::NativeTable {
  typedef AddTargetEvent TableType;
  uint16_t target_id = 0;
  uint32_t frame_number = 0;
  std::unique_ptr<aim::StoredVec3> position{};
  float radius = 0.0f;
  AddTargetEventT() = default;
  AddTargetEventT(const AddTargetEventT &o);
  AddTargetEventT(AddTargetEventT&&) FLATBUFFERS_NOEXCEPT = default;
  AddTargetEventT &operator=(AddTargetEventT o) FLATBUFFERS_NOEXCEPT;
};

struct AddTargetEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AddTargetEventT NativeTableType;
  typedef AddTargetEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_ID = 4,
    VT_FRAME_NUMBER = 6,
    VT_POSITION = 8,
    VT_RADIUS = 10
  };
  uint16_t target_id() const {
    return GetField<uint16_t>(VT_TARGET_ID, 0);
  }
  uint32_t frame_number() const {
    return GetField<uint32_t>(VT_FRAME_NUMBER, 0);
  }
  const aim::StoredVec3 *position() const {
    return GetStruct<const aim::StoredVec3 *>(VT_POSITION);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TARGET_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_NUMBER, 4) &&
           VerifyField<aim::StoredVec3>(verifier, VT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           verifier.EndTable();
  }
  AddTargetEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AddTargetEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AddTargetEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddTargetEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AddTargetEventBuilder {
  typedef AddTargetEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_id(uint16_t target_id) {
    fbb_.AddElement<uint16_t>(AddTargetEvent::VT_TARGET_ID, target_id, 0);
  }
  void add_frame_number(uint32_t frame_number) {
    fbb_.AddElement<uint32_t>(AddTargetEvent::VT_FRAME_NUMBER, frame_number, 0);
  }
  void add_position(const aim::StoredVec3 *position) {
    fbb_.AddStruct(AddTargetEvent::VT_POSITION, position);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(AddTargetEvent::VT_RADIUS, radius, 0.0f);
  }
  explicit AddTargetEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AddTargetEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AddTargetEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AddTargetEvent> CreateAddTargetEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t target_id = 0,
    uint32_t frame_number = 0,
    const aim::StoredVec3 *position = nullptr,
    float radius = 0.0f) {
  AddTargetEventBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_position(position);
  builder_.add_frame_number(frame_number);
  builder_.add_target_id(target_id);
  return builder_.Finish();
}

::flatbuffers::Offset<AddTargetEvent> CreateAddTargetEvent(::flatbuffers::FlatBufferBuilder &_fbb, const AddTargetEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HitTargetEventT : public ::flatbuffers::NativeTable {
  typedef HitTargetEvent TableType;
  uint16_t target_id = 0;
  uint32_t frame_number = 0;
};

struct HitTargetEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef HitTargetEventT NativeTableType;
  typedef HitTargetEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_ID = 4,
    VT_FRAME_NUMBER = 6
  };
  uint16_t target_id() const {
    return GetField<uint16_t>(VT_TARGET_ID, 0);
  }
  uint32_t frame_number() const {
    return GetField<uint32_t>(VT_FRAME_NUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TARGET_ID, 2) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_NUMBER, 4) &&
           verifier.EndTable();
  }
  HitTargetEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HitTargetEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<HitTargetEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HitTargetEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HitTargetEventBuilder {
  typedef HitTargetEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_id(uint16_t target_id) {
    fbb_.AddElement<uint16_t>(HitTargetEvent::VT_TARGET_ID, target_id, 0);
  }
  void add_frame_number(uint32_t frame_number) {
    fbb_.AddElement<uint32_t>(HitTargetEvent::VT_FRAME_NUMBER, frame_number, 0);
  }
  explicit HitTargetEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<HitTargetEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<HitTargetEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<HitTargetEvent> CreateHitTargetEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t target_id = 0,
    uint32_t frame_number = 0) {
  HitTargetEventBuilder builder_(_fbb);
  builder_.add_frame_number(frame_number);
  builder_.add_target_id(target_id);
  return builder_.Finish();
}

::flatbuffers::Offset<HitTargetEvent> CreateHitTargetEvent(::flatbuffers::FlatBufferBuilder &_fbb, const HitTargetEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MissTargetEventT : public ::flatbuffers::NativeTable {
  typedef MissTargetEvent TableType;
  uint32_t frame_number = 0;
};

struct MissTargetEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MissTargetEventT NativeTableType;
  typedef MissTargetEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_NUMBER = 4
  };
  uint32_t frame_number() const {
    return GetField<uint32_t>(VT_FRAME_NUMBER, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME_NUMBER, 4) &&
           verifier.EndTable();
  }
  MissTargetEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MissTargetEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<MissTargetEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MissTargetEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MissTargetEventBuilder {
  typedef MissTargetEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_frame_number(uint32_t frame_number) {
    fbb_.AddElement<uint32_t>(MissTargetEvent::VT_FRAME_NUMBER, frame_number, 0);
  }
  explicit MissTargetEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MissTargetEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MissTargetEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MissTargetEvent> CreateMissTargetEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame_number = 0) {
  MissTargetEventBuilder builder_(_fbb);
  builder_.add_frame_number(frame_number);
  return builder_.Finish();
}

::flatbuffers::Offset<MissTargetEvent> CreateMissTargetEvent(::flatbuffers::FlatBufferBuilder &_fbb, const MissTargetEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StaticReplayT : public ::flatbuffers::NativeTable {
  typedef StaticReplay TableType;
  float wall_width = 0.0f;
  float wall_height = 0.0f;
  uint16_t frames_per_second = 0;
  bool is_poke_ball = false;
  std::unique_ptr<aim::StoredVec3> camera_position{};
  std::vector<std::unique_ptr<aim::AddTargetEventT>> add_target_events{};
  std::vector<std::unique_ptr<aim::HitTargetEventT>> hit_target_events{};
  std::vector<std::unique_ptr<aim::MissTargetEventT>> miss_target_events{};
  std::vector<aim::PitchYaw> pitch_yaw_pairs{};
  StaticReplayT() = default;
  StaticReplayT(const StaticReplayT &o);
  StaticReplayT(StaticReplayT&&) FLATBUFFERS_NOEXCEPT = default;
  StaticReplayT &operator=(StaticReplayT o) FLATBUFFERS_NOEXCEPT;
};

struct StaticReplay FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StaticReplayT NativeTableType;
  typedef StaticReplayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WALL_WIDTH = 4,
    VT_WALL_HEIGHT = 6,
    VT_FRAMES_PER_SECOND = 8,
    VT_IS_POKE_BALL = 10,
    VT_CAMERA_POSITION = 12,
    VT_ADD_TARGET_EVENTS = 14,
    VT_HIT_TARGET_EVENTS = 16,
    VT_MISS_TARGET_EVENTS = 18,
    VT_PITCH_YAW_PAIRS = 20
  };
  float wall_width() const {
    return GetField<float>(VT_WALL_WIDTH, 0.0f);
  }
  float wall_height() const {
    return GetField<float>(VT_WALL_HEIGHT, 0.0f);
  }
  uint16_t frames_per_second() const {
    return GetField<uint16_t>(VT_FRAMES_PER_SECOND, 0);
  }
  bool is_poke_ball() const {
    return GetField<uint8_t>(VT_IS_POKE_BALL, 0) != 0;
  }
  const aim::StoredVec3 *camera_position() const {
    return GetStruct<const aim::StoredVec3 *>(VT_CAMERA_POSITION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<aim::AddTargetEvent>> *add_target_events() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<aim::AddTargetEvent>> *>(VT_ADD_TARGET_EVENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<aim::HitTargetEvent>> *hit_target_events() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<aim::HitTargetEvent>> *>(VT_HIT_TARGET_EVENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<aim::MissTargetEvent>> *miss_target_events() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<aim::MissTargetEvent>> *>(VT_MISS_TARGET_EVENTS);
  }
  const ::flatbuffers::Vector<const aim::PitchYaw *> *pitch_yaw_pairs() const {
    return GetPointer<const ::flatbuffers::Vector<const aim::PitchYaw *> *>(VT_PITCH_YAW_PAIRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WALL_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_WALL_HEIGHT, 4) &&
           VerifyField<uint16_t>(verifier, VT_FRAMES_PER_SECOND, 2) &&
           VerifyField<uint8_t>(verifier, VT_IS_POKE_BALL, 1) &&
           VerifyField<aim::StoredVec3>(verifier, VT_CAMERA_POSITION, 4) &&
           VerifyOffset(verifier, VT_ADD_TARGET_EVENTS) &&
           verifier.VerifyVector(add_target_events()) &&
           verifier.VerifyVectorOfTables(add_target_events()) &&
           VerifyOffset(verifier, VT_HIT_TARGET_EVENTS) &&
           verifier.VerifyVector(hit_target_events()) &&
           verifier.VerifyVectorOfTables(hit_target_events()) &&
           VerifyOffset(verifier, VT_MISS_TARGET_EVENTS) &&
           verifier.VerifyVector(miss_target_events()) &&
           verifier.VerifyVectorOfTables(miss_target_events()) &&
           VerifyOffset(verifier, VT_PITCH_YAW_PAIRS) &&
           verifier.VerifyVector(pitch_yaw_pairs()) &&
           verifier.EndTable();
  }
  StaticReplayT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StaticReplayT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StaticReplay> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StaticReplayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StaticReplayBuilder {
  typedef StaticReplay Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_wall_width(float wall_width) {
    fbb_.AddElement<float>(StaticReplay::VT_WALL_WIDTH, wall_width, 0.0f);
  }
  void add_wall_height(float wall_height) {
    fbb_.AddElement<float>(StaticReplay::VT_WALL_HEIGHT, wall_height, 0.0f);
  }
  void add_frames_per_second(uint16_t frames_per_second) {
    fbb_.AddElement<uint16_t>(StaticReplay::VT_FRAMES_PER_SECOND, frames_per_second, 0);
  }
  void add_is_poke_ball(bool is_poke_ball) {
    fbb_.AddElement<uint8_t>(StaticReplay::VT_IS_POKE_BALL, static_cast<uint8_t>(is_poke_ball), 0);
  }
  void add_camera_position(const aim::StoredVec3 *camera_position) {
    fbb_.AddStruct(StaticReplay::VT_CAMERA_POSITION, camera_position);
  }
  void add_add_target_events(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<aim::AddTargetEvent>>> add_target_events) {
    fbb_.AddOffset(StaticReplay::VT_ADD_TARGET_EVENTS, add_target_events);
  }
  void add_hit_target_events(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<aim::HitTargetEvent>>> hit_target_events) {
    fbb_.AddOffset(StaticReplay::VT_HIT_TARGET_EVENTS, hit_target_events);
  }
  void add_miss_target_events(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<aim::MissTargetEvent>>> miss_target_events) {
    fbb_.AddOffset(StaticReplay::VT_MISS_TARGET_EVENTS, miss_target_events);
  }
  void add_pitch_yaw_pairs(::flatbuffers::Offset<::flatbuffers::Vector<const aim::PitchYaw *>> pitch_yaw_pairs) {
    fbb_.AddOffset(StaticReplay::VT_PITCH_YAW_PAIRS, pitch_yaw_pairs);
  }
  explicit StaticReplayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StaticReplay> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StaticReplay>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StaticReplay> CreateStaticReplay(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float wall_width = 0.0f,
    float wall_height = 0.0f,
    uint16_t frames_per_second = 0,
    bool is_poke_ball = false,
    const aim::StoredVec3 *camera_position = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<aim::AddTargetEvent>>> add_target_events = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<aim::HitTargetEvent>>> hit_target_events = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<aim::MissTargetEvent>>> miss_target_events = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const aim::PitchYaw *>> pitch_yaw_pairs = 0) {
  StaticReplayBuilder builder_(_fbb);
  builder_.add_pitch_yaw_pairs(pitch_yaw_pairs);
  builder_.add_miss_target_events(miss_target_events);
  builder_.add_hit_target_events(hit_target_events);
  builder_.add_add_target_events(add_target_events);
  builder_.add_camera_position(camera_position);
  builder_.add_wall_height(wall_height);
  builder_.add_wall_width(wall_width);
  builder_.add_frames_per_second(frames_per_second);
  builder_.add_is_poke_ball(is_poke_ball);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StaticReplay> CreateStaticReplayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float wall_width = 0.0f,
    float wall_height = 0.0f,
    uint16_t frames_per_second = 0,
    bool is_poke_ball = false,
    const aim::StoredVec3 *camera_position = nullptr,
    const std::vector<::flatbuffers::Offset<aim::AddTargetEvent>> *add_target_events = nullptr,
    const std::vector<::flatbuffers::Offset<aim::HitTargetEvent>> *hit_target_events = nullptr,
    const std::vector<::flatbuffers::Offset<aim::MissTargetEvent>> *miss_target_events = nullptr,
    const std::vector<aim::PitchYaw> *pitch_yaw_pairs = nullptr) {
  auto add_target_events__ = add_target_events ? _fbb.CreateVector<::flatbuffers::Offset<aim::AddTargetEvent>>(*add_target_events) : 0;
  auto hit_target_events__ = hit_target_events ? _fbb.CreateVector<::flatbuffers::Offset<aim::HitTargetEvent>>(*hit_target_events) : 0;
  auto miss_target_events__ = miss_target_events ? _fbb.CreateVector<::flatbuffers::Offset<aim::MissTargetEvent>>(*miss_target_events) : 0;
  auto pitch_yaw_pairs__ = pitch_yaw_pairs ? _fbb.CreateVectorOfStructs<aim::PitchYaw>(*pitch_yaw_pairs) : 0;
  return aim::CreateStaticReplay(
      _fbb,
      wall_width,
      wall_height,
      frames_per_second,
      is_poke_ball,
      camera_position,
      add_target_events__,
      hit_target_events__,
      miss_target_events__,
      pitch_yaw_pairs__);
}

::flatbuffers::Offset<StaticReplay> CreateStaticReplay(::flatbuffers::FlatBufferBuilder &_fbb, const StaticReplayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReplayFileT : public ::flatbuffers::NativeTable {
  typedef ReplayFile TableType;
  aim::ReplayUnion replay{};
};

struct ReplayFile FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReplayFileT NativeTableType;
  typedef ReplayFileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REPLAY_TYPE = 4,
    VT_REPLAY = 6
  };
  aim::Replay replay_type() const {
    return static_cast<aim::Replay>(GetField<uint8_t>(VT_REPLAY_TYPE, 0));
  }
  const void *replay() const {
    return GetPointer<const void *>(VT_REPLAY);
  }
  template<typename T> const T *replay_as() const;
  const aim::StaticReplay *replay_as_static_replay() const {
    return replay_type() == aim::Replay_static_replay ? static_cast<const aim::StaticReplay *>(replay()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REPLAY_TYPE, 1) &&
           VerifyOffset(verifier, VT_REPLAY) &&
           VerifyReplay(verifier, replay(), replay_type()) &&
           verifier.EndTable();
  }
  ReplayFileT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReplayFileT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReplayFile> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReplayFileT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const aim::StaticReplay *ReplayFile::replay_as<aim::StaticReplay>() const {
  return replay_as_static_replay();
}

struct ReplayFileBuilder {
  typedef ReplayFile Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_replay_type(aim::Replay replay_type) {
    fbb_.AddElement<uint8_t>(ReplayFile::VT_REPLAY_TYPE, static_cast<uint8_t>(replay_type), 0);
  }
  void add_replay(::flatbuffers::Offset<void> replay) {
    fbb_.AddOffset(ReplayFile::VT_REPLAY, replay);
  }
  explicit ReplayFileBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReplayFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReplayFile>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReplayFile> CreateReplayFile(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    aim::Replay replay_type = aim::Replay_NONE,
    ::flatbuffers::Offset<void> replay = 0) {
  ReplayFileBuilder builder_(_fbb);
  builder_.add_replay(replay);
  builder_.add_replay_type(replay_type);
  return builder_.Finish();
}

::flatbuffers::Offset<ReplayFile> CreateReplayFile(::flatbuffers::FlatBufferBuilder &_fbb, const ReplayFileT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline AddTargetEventT::AddTargetEventT(const AddTargetEventT &o)
      : target_id(o.target_id),
        frame_number(o.frame_number),
        position((o.position) ? new aim::StoredVec3(*o.position) : nullptr),
        radius(o.radius) {
}

inline AddTargetEventT &AddTargetEventT::operator=(AddTargetEventT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target_id, o.target_id);
  std::swap(frame_number, o.frame_number);
  std::swap(position, o.position);
  std::swap(radius, o.radius);
  return *this;
}

inline AddTargetEventT *AddTargetEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AddTargetEventT>(new AddTargetEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AddTargetEvent::UnPackTo(AddTargetEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_id(); _o->target_id = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<aim::StoredVec3>(new aim::StoredVec3(*_e)); }
  { auto _e = radius(); _o->radius = _e; }
}

inline ::flatbuffers::Offset<AddTargetEvent> AddTargetEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AddTargetEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAddTargetEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AddTargetEvent> CreateAddTargetEvent(::flatbuffers::FlatBufferBuilder &_fbb, const AddTargetEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AddTargetEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_id = _o->target_id;
  auto _frame_number = _o->frame_number;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _radius = _o->radius;
  return aim::CreateAddTargetEvent(
      _fbb,
      _target_id,
      _frame_number,
      _position,
      _radius);
}

inline HitTargetEventT *HitTargetEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HitTargetEventT>(new HitTargetEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HitTargetEvent::UnPackTo(HitTargetEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_id(); _o->target_id = _e; }
  { auto _e = frame_number(); _o->frame_number = _e; }
}

inline ::flatbuffers::Offset<HitTargetEvent> HitTargetEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const HitTargetEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHitTargetEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<HitTargetEvent> CreateHitTargetEvent(::flatbuffers::FlatBufferBuilder &_fbb, const HitTargetEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const HitTargetEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_id = _o->target_id;
  auto _frame_number = _o->frame_number;
  return aim::CreateHitTargetEvent(
      _fbb,
      _target_id,
      _frame_number);
}

inline MissTargetEventT *MissTargetEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MissTargetEventT>(new MissTargetEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MissTargetEvent::UnPackTo(MissTargetEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame_number(); _o->frame_number = _e; }
}

inline ::flatbuffers::Offset<MissTargetEvent> MissTargetEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const MissTargetEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMissTargetEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<MissTargetEvent> CreateMissTargetEvent(::flatbuffers::FlatBufferBuilder &_fbb, const MissTargetEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const MissTargetEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame_number = _o->frame_number;
  return aim::CreateMissTargetEvent(
      _fbb,
      _frame_number);
}

inline StaticReplayT::StaticReplayT(const StaticReplayT &o)
      : wall_width(o.wall_width),
        wall_height(o.wall_height),
        frames_per_second(o.frames_per_second),
        is_poke_ball(o.is_poke_ball),
        camera_position((o.camera_position) ? new aim::StoredVec3(*o.camera_position) : nullptr),
        pitch_yaw_pairs(o.pitch_yaw_pairs) {
  add_target_events.reserve(o.add_target_events.size());
  for (const auto &add_target_events_ : o.add_target_events) { add_target_events.emplace_back((add_target_events_) ? new aim::AddTargetEventT(*add_target_events_) : nullptr); }
  hit_target_events.reserve(o.hit_target_events.size());
  for (const auto &hit_target_events_ : o.hit_target_events) { hit_target_events.emplace_back((hit_target_events_) ? new aim::HitTargetEventT(*hit_target_events_) : nullptr); }
  miss_target_events.reserve(o.miss_target_events.size());
  for (const auto &miss_target_events_ : o.miss_target_events) { miss_target_events.emplace_back((miss_target_events_) ? new aim::MissTargetEventT(*miss_target_events_) : nullptr); }
}

inline StaticReplayT &StaticReplayT::operator=(StaticReplayT o) FLATBUFFERS_NOEXCEPT {
  std::swap(wall_width, o.wall_width);
  std::swap(wall_height, o.wall_height);
  std::swap(frames_per_second, o.frames_per_second);
  std::swap(is_poke_ball, o.is_poke_ball);
  std::swap(camera_position, o.camera_position);
  std::swap(add_target_events, o.add_target_events);
  std::swap(hit_target_events, o.hit_target_events);
  std::swap(miss_target_events, o.miss_target_events);
  std::swap(pitch_yaw_pairs, o.pitch_yaw_pairs);
  return *this;
}

inline StaticReplayT *StaticReplay::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StaticReplayT>(new StaticReplayT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StaticReplay::UnPackTo(StaticReplayT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = wall_width(); _o->wall_width = _e; }
  { auto _e = wall_height(); _o->wall_height = _e; }
  { auto _e = frames_per_second(); _o->frames_per_second = _e; }
  { auto _e = is_poke_ball(); _o->is_poke_ball = _e; }
  { auto _e = camera_position(); if (_e) _o->camera_position = std::unique_ptr<aim::StoredVec3>(new aim::StoredVec3(*_e)); }
  { auto _e = add_target_events(); if (_e) { _o->add_target_events.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->add_target_events[_i]) { _e->Get(_i)->UnPackTo(_o->add_target_events[_i].get(), _resolver); } else { _o->add_target_events[_i] = std::unique_ptr<aim::AddTargetEventT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->add_target_events.resize(0); } }
  { auto _e = hit_target_events(); if (_e) { _o->hit_target_events.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->hit_target_events[_i]) { _e->Get(_i)->UnPackTo(_o->hit_target_events[_i].get(), _resolver); } else { _o->hit_target_events[_i] = std::unique_ptr<aim::HitTargetEventT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->hit_target_events.resize(0); } }
  { auto _e = miss_target_events(); if (_e) { _o->miss_target_events.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->miss_target_events[_i]) { _e->Get(_i)->UnPackTo(_o->miss_target_events[_i].get(), _resolver); } else { _o->miss_target_events[_i] = std::unique_ptr<aim::MissTargetEventT>(_e->Get(_i)->UnPack(_resolver)); } } } else { _o->miss_target_events.resize(0); } }
  { auto _e = pitch_yaw_pairs(); if (_e) { _o->pitch_yaw_pairs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pitch_yaw_pairs[_i] = *_e->Get(_i); } } else { _o->pitch_yaw_pairs.resize(0); } }
}

inline ::flatbuffers::Offset<StaticReplay> StaticReplay::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StaticReplayT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStaticReplay(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StaticReplay> CreateStaticReplay(::flatbuffers::FlatBufferBuilder &_fbb, const StaticReplayT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StaticReplayT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _wall_width = _o->wall_width;
  auto _wall_height = _o->wall_height;
  auto _frames_per_second = _o->frames_per_second;
  auto _is_poke_ball = _o->is_poke_ball;
  auto _camera_position = _o->camera_position ? _o->camera_position.get() : nullptr;
  auto _add_target_events = _o->add_target_events.size() ? _fbb.CreateVector<::flatbuffers::Offset<aim::AddTargetEvent>> (_o->add_target_events.size(), [](size_t i, _VectorArgs *__va) { return CreateAddTargetEvent(*__va->__fbb, __va->__o->add_target_events[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _hit_target_events = _o->hit_target_events.size() ? _fbb.CreateVector<::flatbuffers::Offset<aim::HitTargetEvent>> (_o->hit_target_events.size(), [](size_t i, _VectorArgs *__va) { return CreateHitTargetEvent(*__va->__fbb, __va->__o->hit_target_events[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _miss_target_events = _o->miss_target_events.size() ? _fbb.CreateVector<::flatbuffers::Offset<aim::MissTargetEvent>> (_o->miss_target_events.size(), [](size_t i, _VectorArgs *__va) { return CreateMissTargetEvent(*__va->__fbb, __va->__o->miss_target_events[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _pitch_yaw_pairs = _o->pitch_yaw_pairs.size() ? _fbb.CreateVectorOfStructs(_o->pitch_yaw_pairs) : 0;
  return aim::CreateStaticReplay(
      _fbb,
      _wall_width,
      _wall_height,
      _frames_per_second,
      _is_poke_ball,
      _camera_position,
      _add_target_events,
      _hit_target_events,
      _miss_target_events,
      _pitch_yaw_pairs);
}

inline ReplayFileT *ReplayFile::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReplayFileT>(new ReplayFileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReplayFile::UnPackTo(ReplayFileT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = replay_type(); _o->replay.type = _e; }
  { auto _e = replay(); if (_e) _o->replay.value = aim::ReplayUnion::UnPack(_e, replay_type(), _resolver); }
}

inline ::flatbuffers::Offset<ReplayFile> ReplayFile::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReplayFileT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReplayFile(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReplayFile> CreateReplayFile(::flatbuffers::FlatBufferBuilder &_fbb, const ReplayFileT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReplayFileT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _replay_type = _o->replay.type;
  auto _replay = _o->replay.Pack(_fbb);
  return aim::CreateReplayFile(
      _fbb,
      _replay_type,
      _replay);
}

inline bool VerifyReplay(::flatbuffers::Verifier &verifier, const void *obj, Replay type) {
  switch (type) {
    case Replay_NONE: {
      return true;
    }
    case Replay_static_replay: {
      auto ptr = reinterpret_cast<const aim::StaticReplay *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyReplayVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReplay(
        verifier,  values->Get(i), types->GetEnum<Replay>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ReplayUnion::UnPack(const void *obj, Replay type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Replay_static_replay: {
      auto ptr = reinterpret_cast<const aim::StaticReplay *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ReplayUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Replay_static_replay: {
      auto ptr = reinterpret_cast<const aim::StaticReplayT *>(value);
      return CreateStaticReplay(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ReplayUnion::ReplayUnion(const ReplayUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Replay_static_replay: {
      value = new aim::StaticReplayT(*reinterpret_cast<aim::StaticReplayT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ReplayUnion::Reset() {
  switch (type) {
    case Replay_static_replay: {
      auto ptr = reinterpret_cast<aim::StaticReplayT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Replay_NONE;
}

inline const aim::ReplayFile *GetReplayFile(const void *buf) {
  return ::flatbuffers::GetRoot<aim::ReplayFile>(buf);
}

inline const aim::ReplayFile *GetSizePrefixedReplayFile(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<aim::ReplayFile>(buf);
}

inline const char *ReplayFileIdentifier() {
  return "RPLY";
}

inline bool ReplayFileBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ReplayFileIdentifier());
}

inline bool SizePrefixedReplayFileBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ReplayFileIdentifier(), true);
}

inline bool VerifyReplayFileBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<aim::ReplayFile>(ReplayFileIdentifier());
}

inline bool VerifySizePrefixedReplayFileBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<aim::ReplayFile>(ReplayFileIdentifier());
}

inline void FinishReplayFileBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<aim::ReplayFile> root) {
  fbb.Finish(root, ReplayFileIdentifier());
}

inline void FinishSizePrefixedReplayFileBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<aim::ReplayFile> root) {
  fbb.FinishSizePrefixed(root, ReplayFileIdentifier());
}

inline std::unique_ptr<aim::ReplayFileT> UnPackReplayFile(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<aim::ReplayFileT>(GetReplayFile(buf)->UnPack(res));
}

inline std::unique_ptr<aim::ReplayFileT> UnPackSizePrefixedReplayFile(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<aim::ReplayFileT>(GetSizePrefixedReplayFile(buf)->UnPack(res));
}

}  // namespace aim

#endif  // FLATBUFFERS_GENERATED_REPLAY_AIM_H_
